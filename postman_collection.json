{
  "info": {
    "_postman_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "name": "Multi-Tenant NestJS API - Comprehensive Collection",
    "description": "Complete API collection for the Multi-Tenant NestJS Starter with Google OAuth, Notifications, Monitoring, and all system endpoints. This collection includes comprehensive test scripts, environment variable management, and realistic examples for all API functionality.\n\n## Features Covered:\n- Complete Authentication flows (Basic + Google OAuth)\n- Tenant Management with Google SSO settings\n- User, Role, and Permission Management\n- Project Management\n- Comprehensive Notification System\n- Health Checks and System Monitoring\n- Proper tenant isolation and security\n\n## Usage:\n1. Set up your environment variables (baseUrl, etc.)\n2. Start with tenant registration or use existing tenant\n3. Authenticate to get access token\n4. Use any endpoint with proper authentication\n\n## Environment Variables:\nAll necessary variables are automatically captured during API interactions.",
    "version": "2.0.0",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "auth": {
    "type": "bearer",
    "bearer": [
      {
        "key": "token",
        "value": "{{accessToken}}",
        "type": "string"
      }
    ]
  },
  "event": [
    {
      "listen": "prerequest",
      "script": {
        "type": "text/javascript",
        "exec": [
          "// Global pre-request script for common setup",
          "// Ensure tenant header is set for authenticated requests",
          "if (pm.collectionVariables.get('tenantId') && !pm.request.headers.has('x-tenant-id')) {",
          "    pm.request.headers.add({",
          "        key: 'x-tenant-id',",
          "        value: pm.collectionVariables.get('tenantId')",
          "    });",
          "}",
          "",
          "// Set common headers",
          "pm.request.headers.add({",
          "    key: 'User-Agent',",
          "    value: 'Postman-Collection/2.0.0'",
          "});",
          "",
          "// Log request for debugging",
          "console.log(`Making ${pm.request.method} request to: ${pm.request.url}`);"
        ]
      }
    },
    {
      "listen": "test",
      "script": {
        "type": "text/javascript",
        "exec": [
          "// Global test script for common validations",
          "pm.test('Response time is acceptable', function () {",
          "    pm.expect(pm.response.responseTime).to.be.below(5000);",
          "});",
          "",
          "pm.test('Response has proper content type', function () {",
          "    const contentType = pm.response.headers.get('Content-Type');",
          "    if (contentType) {",
          "        pm.expect(contentType).to.include('application/json');",
          "    }",
          "});",
          "",
          "// Authentication-specific global validations",
          "if (pm.request.url.toString().includes('/auth/')) {",
          "    // Validate authentication endpoints have proper error handling",
          "    if (pm.response.code >= 400) {",
          "        pm.test('Auth error response has message', function () {",
          "            const responseJson = pm.response.json();",
          "            pm.expect(responseJson).to.have.property('message');",
          "        });",
          "    }",
          "    ",
          "    // Log authentication-specific metrics",
          "    if (pm.response.code === 200 && pm.response.json().accessToken) {",
          "        console.log('üîë Access token received and will be captured');",
          "    }",
          "    ",
          "    // Validate rate limiting for auth endpoints",
          "    if (pm.response.code === 429) {",
          "        console.log('‚ö†Ô∏è Rate limit hit on authentication endpoint');",
          "        pm.test('Rate limit response has retry information', function () {",
          "            const headers = pm.response.headers;",
          "            // Should have some indication of when to retry",
          "            const hasRetryAfter = headers.has('Retry-After') || headers.has('X-RateLimit-Reset');",
          "            pm.expect(hasRetryAfter).to.be.true;",
          "        });",
          "    }",
          "}",
          "",
          "// Security validation for all endpoints",
          "pm.test('Response does not leak sensitive information', function () {",
          "    const responseText = pm.response.text().toLowerCase();",
          "    const sensitivePatterns = [",
          "        /password[\"']?\\s*:\\s*[\"'][^\"']+[\"']/,",
          "        /secret[\"']?\\s*:\\s*[\"'][^\"']+[\"']/,",
          "        /private[_-]?key/,",
          "        /database[_-]?url/",
          "    ];",
          "    ",
          "    sensitivePatterns.forEach(pattern => {",
          "        pm.expect(responseText).to.not.match(pattern);",
          "    });",
          "});",
          "",
          "// Log response status for debugging",
          "console.log(`Response status: ${pm.response.status} (${pm.response.code})`);"
        ]
      }
    }
  ],
  "variable": [
    {
      "key": "baseUrl",
      "value": "http://localhost:3000/api",
      "type": "string",
      "description": "Base URL for the API (development: http://localhost:3000/api, production: update as needed)"
    },
    {
      "key": "tenantId",
      "value": "",
      "type": "string",
      "description": "Current tenant identifier - automatically captured during tenant registration or login"
    },
    {
      "key": "accessToken",
      "value": "",
      "type": "string",
      "description": "JWT authentication token - automatically captured during login"
    },
    {
      "key": "userId",
      "value": "",
      "type": "string",
      "description": "Current user ID - automatically captured during user operations"
    },
    {
      "key": "roleId",
      "value": "",
      "type": "string",
      "description": "Role ID for testing role operations - automatically captured during role creation"
    },
    {
      "key": "permissionId",
      "value": "",
      "type": "string",
      "description": "Permission ID for testing permission operations - automatically captured during permission creation"
    },
    {
      "key": "projectId",
      "value": "",
      "type": "string",
      "description": "Project ID for testing project operations - automatically captured during project creation"
    },
    {
      "key": "notificationId",
      "value": "",
      "type": "string",
      "description": "Notification ID for testing notification operations - automatically captured during notification creation"
    },
    {
      "key": "googleAuthUrl",
      "value": "",
      "type": "string",
      "description": "Google OAuth authorization URL - automatically captured during OAuth initiation"
    },
    {
      "key": "googleState",
      "value": "",
      "type": "string",
      "description": "Google OAuth state parameter - automatically captured during OAuth flow"
    },
    {
      "key": "googleCode",
      "value": "",
      "type": "string",
      "description": "Google OAuth authorization code - manually set from OAuth callback"
    },
    {
      "key": "refreshToken",
      "value": "",
      "type": "string",
      "description": "JWT refresh token - automatically captured when available"
    },
    {
      "key": "adminUserId",
      "value": "",
      "type": "string",
      "description": "Admin user ID for testing admin operations - automatically captured during tenant registration"
    },
    {
      "key": "testEmail",
      "value": "test@example.com",
      "type": "string",
      "description": "Test email address for user operations"
    },
    {
      "key": "testPassword",
      "value": "TestPass123!",
      "type": "string",
      "description": "Test password for user operations"
    },
    {
      "key": "googleLinkUrl",
      "value": "",
      "type": "string",
      "description": "Google OAuth URL for account linking - automatically captured during linking initiation"
    },
    {
      "key": "googleLinkState",
      "value": "",
      "type": "string",
      "description": "Google OAuth state for account linking - automatically captured during linking initiation"
    },
    {
      "key": "googleLinkCode",
      "value": "",
      "type": "string",
      "description": "Google OAuth authorization code for linking - manually set from OAuth callback"
    }
  ],
  "item": [
    {
      "name": "üè• Environment Setup",
      "description": "Initial setup and health check endpoints to verify system status before testing",
      "item": [
        {
          "name": "Health Checks",
          "description": "Basic health check endpoints to verify system components",
          "item": [
            {
              "name": "Application Health Check",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "User-Agent",
                    "value": "Postman-Collection/2.0.0",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    ""
                  ]
                },
                "description": "Basic application health check endpoint. This is the root endpoint that provides a simple health status for the entire application.\n\n**Authentication:** None required (public endpoint)\n**Rate Limiting:** None\n\n**Expected Response:** 200 OK with \"Hello World!\" message\n\n**Use Cases:**\n- Load balancer health checks\n- Basic application availability monitoring\n- Initial connectivity testing\n- Service discovery validation\n\n**Response Format:**\n```\nHello World!\n```\n\n**Error Scenarios:**\n- 503 Service Unavailable: Application is starting up or shutting down\n- 500 Internal Server Error: Application has critical issues"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Application Health Check Test Suite",
                      "",
                      "pm.test('Application is responding', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(2000);",
                      "});",
                      "",
                      "pm.test('Application returns expected message', function () {",
                      "    pm.expect(pm.response.text()).to.equal('Hello World!');",
                      "});",
                      "",
                      "pm.test('Response headers are present', function () {",
                      "    pm.expect(pm.response.headers.get('Content-Type')).to.exist;",
                      "});",
                      "",
                      "// Log health status",
                      "if (pm.response.code === 200) {",
                      "    console.log('‚úÖ Application is healthy and responding');",
                      "    console.log('üìä Response time:', pm.response.responseTime + 'ms');",
                      "} else {",
                      "    console.log('‚ùå Application health check failed');",
                      "    console.log('üìä Status code:', pm.response.code);",
                      "    console.log('üìä Response:', pm.response.text());",
                      "}",
                      "",
                      "// Performance monitoring",
                      "if (pm.response.responseTime > 1000) {",
                      "    console.log('‚ö†Ô∏è Warning: Application response time is slow');",
                      "} else if (pm.response.responseTime < 100) {",
                      "    console.log('üöÄ Excellent: Application response time is very fast');",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Google OAuth Health Check",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "User-Agent",
                    "value": "Postman-Collection/2.0.0",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/health/google-oauth",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "health",
                    "google-oauth"
                  ]
                },
                "description": "Comprehensive Google OAuth health check endpoint. This endpoint validates Google OAuth configuration, connectivity, and service availability.\n\n**Authentication:** None required (public endpoint)\n**Rate Limiting:** Skipped for monitoring purposes\n\n**Response Format:**\n```json\n{\n  \"status\": \"ok\" | \"error\",\n  \"configured\": boolean,\n  \"timestamp\": \"ISO-8601-timestamp\",\n  \"details\": {\n    \"clientConfigured\": boolean,\n    \"redirectUriValid\": boolean,\n    \"scopesValid\": boolean,\n    \"authUrlGeneration\": boolean\n  },\n  \"error\": \"error-message\" // Only present if status is 'error'\n}\n```\n\n**Use Cases:**\n- Google OAuth service monitoring\n- Configuration validation\n- Integration health checks\n- Troubleshooting OAuth issues\n\n**Health Check Validations:**\n- Google OAuth client configuration\n- Redirect URI validation\n- Scope configuration\n- Auth URL generation capability\n\n**Error Scenarios:**\n- Missing Google OAuth configuration\n- Invalid client credentials\n- Network connectivity issues\n- Service configuration errors"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Google OAuth Health Check Test Suite",
                      "",
                      "pm.test('Google OAuth health endpoint responds', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable for health check', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});",
                      "",
                      "pm.test('Response has valid JSON structure', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('object');",
                      "    pm.expect(responseJson).to.have.property('status');",
                      "    pm.expect(responseJson).to.have.property('configured');",
                      "    pm.expect(responseJson).to.have.property('timestamp');",
                      "});",
                      "",
                      "pm.test('Health status is valid', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson.status).to.be.oneOf(['ok', 'error']);",
                      "    pm.expect(responseJson.configured).to.be.a('boolean');",
                      "});",
                      "",
                      "pm.test('Timestamp is valid ISO format', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const timestamp = new Date(responseJson.timestamp);",
                      "    pm.expect(timestamp.toISOString()).to.equal(responseJson.timestamp);",
                      "});",
                      "",
                      "// Detailed health validation",
                      "const responseJson = pm.response.json();",
                      "",
                      "if (responseJson.status === 'ok') {",
                      "    pm.test('Google OAuth is healthy', function () {",
                      "        pm.expect(responseJson.configured).to.be.true;",
                      "        pm.expect(responseJson).to.have.property('details');",
                      "    });",
                      "    ",
                      "    pm.test('OAuth configuration details are valid', function () {",
                      "        const details = responseJson.details;",
                      "        pm.expect(details).to.have.property('clientConfigured');",
                      "        pm.expect(details).to.have.property('redirectUriValid');",
                      "        pm.expect(details).to.have.property('scopesValid');",
                      "        pm.expect(details).to.have.property('authUrlGeneration');",
                      "    });",
                      "    ",
                      "    console.log('‚úÖ Google OAuth is healthy and properly configured');",
                      "    console.log('üìä Configuration details:', JSON.stringify(responseJson.details, null, 2));",
                      "} else {",
                      "    pm.test('Error response has proper error information', function () {",
                      "        pm.expect(responseJson).to.have.property('error');",
                      "        pm.expect(responseJson.error).to.be.a('string');",
                      "        pm.expect(responseJson.error.length).to.be.greaterThan(0);",
                      "    });",
                      "    ",
                      "    console.log('‚ùå Google OAuth health check failed');",
                      "    console.log('üìä Error:', responseJson.error);",
                      "    console.log('üìä Configured:', responseJson.configured);",
                      "}",
                      "",
                      "// Performance and reliability metrics",
                      "console.log('üìä Health check metrics:');",
                      "console.log('  Response time:', pm.response.responseTime + 'ms');",
                      "console.log('  Status:', responseJson.status);",
                      "console.log('  Configured:', responseJson.configured);",
                      "console.log('  Timestamp:', responseJson.timestamp);",
                      "",
                      "// Alert on performance issues",
                      "if (pm.response.responseTime > 2000) {",
                      "    console.log('‚ö†Ô∏è Warning: Google OAuth health check is slow');",
                      "}",
                      "",
                      "// Alert on configuration issues",
                      "if (responseJson.status === 'error' || !responseJson.configured) {",
                      "    console.log('üö® Alert: Google OAuth configuration issues detected');",
                      "    console.log('üí° Tip: Check Google OAuth client configuration and credentials');",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Google OAuth Status Check",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "User-Agent",
                    "value": "Postman-Collection/2.0.0",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/health/google-oauth/status",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "health",
                    "google-oauth",
                    "status"
                  ]
                },
                "description": "Simplified Google OAuth status check endpoint that returns HTTP status codes for monitoring systems that only check status codes (like load balancers).\n\n**Authentication:** None required (public endpoint)\n**Rate Limiting:** Skipped for monitoring purposes\n\n**Response Codes:**\n- `200 OK`: Google OAuth is healthy and configured\n- `503 Service Unavailable`: Google OAuth is unhealthy or misconfigured\n\n**Response Format (Success):**\n```json\n{\n  \"status\": \"healthy\"\n}\n```\n\n**Response Format (Error):**\n```json\n{\n  \"message\": \"Google OAuth service is unhealthy\",\n  \"statusCode\": 503\n}\n```\n\n**Use Cases:**\n- Load balancer health checks\n- Simple monitoring systems\n- Automated health monitoring\n- Service mesh health checks\n- Container orchestration health probes\n\n**Integration Notes:**\n- This endpoint is designed for systems that only check HTTP status codes\n- Use the detailed `/health/google-oauth` endpoint for comprehensive diagnostics\n- Suitable for Kubernetes liveness/readiness probes"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Google OAuth Status Check Test Suite",
                      "",
                      "pm.test('Status endpoint responds with valid HTTP code', function () {",
                      "    // Should be either 200 (healthy) or 503 (unhealthy)",
                      "    pm.expect(pm.response.code).to.be.oneOf([200, 503]);",
                      "});",
                      "",
                      "pm.test('Response time is fast for status check', function () {",
                      "    // Status checks should be very fast",
                      "    pm.expect(pm.response.responseTime).to.be.below(1500);",
                      "});",
                      "",
                      "pm.test('Response has JSON content type', function () {",
                      "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                      "});",
                      "",
                      "// Test based on response code",
                      "if (pm.response.code === 200) {",
                      "    pm.test('Healthy response has correct format', function () {",
                      "        const responseJson = pm.response.json();",
                      "        pm.expect(responseJson).to.have.property('status');",
                      "        pm.expect(responseJson.status).to.equal('healthy');",
                      "    });",
                      "    ",
                      "    console.log('‚úÖ Google OAuth status: HEALTHY');",
                      "    console.log('üìä Service is ready for OAuth operations');",
                      "    ",
                      "} else if (pm.response.code === 503) {",
                      "    pm.test('Unhealthy response has error information', function () {",
                      "        const responseJson = pm.response.json();",
                      "        pm.expect(responseJson).to.have.property('message');",
                      "        pm.expect(responseJson).to.have.property('statusCode');",
                      "        pm.expect(responseJson.statusCode).to.equal(503);",
                      "    });",
                      "    ",
                      "    console.log('‚ùå Google OAuth status: UNHEALTHY');",
                      "    console.log('üìä Service is not ready for OAuth operations');",
                      "    console.log('üí° Check the detailed health endpoint for more information');",
                      "}",
                      "",
                      "// Performance monitoring",
                      "console.log('üìä Status check metrics:');",
                      "console.log('  Response time:', pm.response.responseTime + 'ms');",
                      "console.log('  HTTP status:', pm.response.code);",
                      "console.log('  Service status:', pm.response.code === 200 ? 'HEALTHY' : 'UNHEALTHY');",
                      "",
                      "// Performance alerts",
                      "if (pm.response.responseTime > 1000) {",
                      "    console.log('‚ö†Ô∏è Warning: Status check response time is slow');",
                      "    console.log('üí° Consider investigating system performance');",
                      "}",
                      "",
                      "// Service availability alerts",
                      "if (pm.response.code === 503) {",
                      "    console.log('üö® Alert: Google OAuth service is unavailable');",
                      "    console.log('üí° Action required: Check service configuration and connectivity');",
                      "    console.log('üîß Next steps: Run detailed health check for diagnostics');",
                      "}",
                      "",
                      "// Success confirmation",
                      "if (pm.response.code === 200 && pm.response.responseTime < 500) {",
                      "    console.log('üöÄ Excellent: Google OAuth service is healthy and responsive');",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Health Check Validation Suite",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "User-Agent",
                    "value": "Postman-Collection/2.0.0",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/health/google-oauth",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "health",
                    "google-oauth"
                  ]
                },
                "description": "Comprehensive health check validation suite that tests multiple health scenarios and validates system resilience.\n\n**Test Coverage:**\n- Response time performance validation\n- Error handling and recovery testing\n- Configuration validation\n- Service availability monitoring\n- Security validation for health endpoints\n\n**Validation Scenarios:**\n- Normal operation validation\n- Error condition handling\n- Performance threshold testing\n- Configuration drift detection\n- Service dependency validation\n\n**Use Cases:**\n- Comprehensive system health validation\n- Pre-deployment health checks\n- Continuous monitoring validation\n- Health endpoint security testing\n- Performance regression testing"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Comprehensive Health Check Validation Suite",
                      "",
                      "// === BASIC CONNECTIVITY TESTS ===",
                      "pm.test('Health endpoint is accessible', function () {",
                      "    pm.expect(pm.response.code).to.be.oneOf([200, 503]);",
                      "});",
                      "",
                      "pm.test('Response time meets SLA requirements', function () {",
                      "    // Health checks should respond within 3 seconds",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});",
                      "",
                      "// === RESPONSE FORMAT VALIDATION ===",
                      "pm.test('Response format is valid JSON', function () {",
                      "    pm.expect(() => pm.response.json()).to.not.throw();",
                      "});",
                      "",
                      "pm.test('Response has required health check fields', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('status');",
                      "    pm.expect(responseJson).to.have.property('configured');",
                      "    pm.expect(responseJson).to.have.property('timestamp');",
                      "});",
                      "",
                      "// === SECURITY VALIDATION ===",
                      "pm.test('Health endpoint does not expose sensitive information', function () {",
                      "    const responseText = pm.response.text().toLowerCase();",
                      "    const sensitivePatterns = [",
                      "        /client[_-]?secret/,",
                      "        /private[_-]?key/,",
                      "        /password/,",
                      "        /token/,",
                      "        /credential/",
                      "    ];",
                      "    ",
                      "    sensitivePatterns.forEach(pattern => {",
                      "        pm.expect(responseText).to.not.match(pattern);",
                      "    });",
                      "});",
                      "",
                      "pm.test('Health endpoint has appropriate caching headers', function () {",
                      "    // Health checks should not be cached",
                      "    const cacheControl = pm.response.headers.get('Cache-Control');",
                      "    if (cacheControl) {",
                      "        pm.expect(cacheControl.toLowerCase()).to.include('no-cache');",
                      "    }",
                      "});",
                      "",
                      "// === PERFORMANCE VALIDATION ===",
                      "const responseJson = pm.response.json();",
                      "",
                      "pm.test('Health check timestamp is recent', function () {",
                      "    const timestamp = new Date(responseJson.timestamp);",
                      "    const now = new Date();",
                      "    const timeDiff = Math.abs(now.getTime() - timestamp.getTime());",
                      "    ",
                      "    // Timestamp should be within last 10 seconds",
                      "    pm.expect(timeDiff).to.be.below(10000);",
                      "});",
                      "",
                      "// === SERVICE HEALTH VALIDATION ===",
                      "if (responseJson.status === 'ok') {",
                      "    pm.test('Healthy service has complete configuration details', function () {",
                      "        pm.expect(responseJson.configured).to.be.true;",
                      "        pm.expect(responseJson).to.have.property('details');",
                      "        ",
                      "        const details = responseJson.details;",
                      "        pm.expect(details).to.have.property('clientConfigured');",
                      "        pm.expect(details).to.have.property('redirectUriValid');",
                      "        pm.expect(details).to.have.property('scopesValid');",
                      "        pm.expect(details).to.have.property('authUrlGeneration');",
                      "    });",
                      "    ",
                      "    pm.test('All configuration components are healthy', function () {",
                      "        const details = responseJson.details;",
                      "        pm.expect(details.clientConfigured).to.be.true;",
                      "        pm.expect(details.redirectUriValid).to.be.true;",
                      "        pm.expect(details.scopesValid).to.be.true;",
                      "        pm.expect(details.authUrlGeneration).to.be.true;",
                      "    });",
                      "}",
                      "",
                      "// === ERROR HANDLING VALIDATION ===",
                      "if (responseJson.status === 'error') {",
                      "    pm.test('Error response provides actionable information', function () {",
                      "        pm.expect(responseJson).to.have.property('error');",
                      "        pm.expect(responseJson.error).to.be.a('string');",
                      "        pm.expect(responseJson.error.length).to.be.greaterThan(10);",
                      "    });",
                      "}",
                      "",
                      "// === COMPREHENSIVE LOGGING ===",
                      "console.log('üè• === HEALTH CHECK VALIDATION REPORT ===');",
                      "console.log('üìä Overall Status:', responseJson.status.toUpperCase());",
                      "console.log('üìä Configuration Status:', responseJson.configured ? 'CONFIGURED' : 'NOT CONFIGURED');",
                      "console.log('üìä Response Time:', pm.response.responseTime + 'ms');",
                      "console.log('üìä Timestamp:', responseJson.timestamp);",
                      "",
                      "if (responseJson.status === 'ok') {",
                      "    console.log('‚úÖ === SERVICE HEALTH: EXCELLENT ===');",
                      "    console.log('üìä Configuration Details:');",
                      "    Object.entries(responseJson.details).forEach(([key, value]) => {",
                      "        console.log(`  ${key}: ${value ? '‚úÖ' : '‚ùå'}`);",
                      "    });",
                      "} else {",
                      "    console.log('‚ùå === SERVICE HEALTH: ISSUES DETECTED ===');",
                      "    console.log('üìä Error Details:', responseJson.error);",
                      "}",
                      "",
                      "// === PERFORMANCE ANALYSIS ===",
                      "console.log('üìä === PERFORMANCE ANALYSIS ===');",
                      "if (pm.response.responseTime < 500) {",
                      "    console.log('üöÄ Performance: EXCELLENT (< 500ms)');",
                      "} else if (pm.response.responseTime < 1000) {",
                      "    console.log('‚úÖ Performance: GOOD (< 1s)');",
                      "} else if (pm.response.responseTime < 2000) {",
                      "    console.log('‚ö†Ô∏è Performance: ACCEPTABLE (< 2s)');",
                      "} else {",
                      "    console.log('‚ùå Performance: POOR (> 2s)');",
                      "}",
                      "",
                      "// === RECOMMENDATIONS ===",
                      "console.log('üí° === RECOMMENDATIONS ===');",
                      "if (responseJson.status === 'error') {",
                      "    console.log('üîß Action Required: Fix Google OAuth configuration');",
                      "    console.log('üìñ Check: Environment variables and Google Cloud Console settings');",
                      "}",
                      "if (pm.response.responseTime > 1000) {",
                      "    console.log('‚ö° Consider: Optimizing health check performance');",
                      "}",
                      "if (responseJson.status === 'ok' && pm.response.responseTime < 500) {",
                      "    console.log('üéâ Status: System is healthy and performing optimally');",
                      "}",
                      "",
                      "console.log('üè• === END HEALTH CHECK REPORT ===');"
                    ]
                  }
                }
              ]
            }
          ]
        },
        {
          "name": "Configuration Tests",
          "description": "Test environment configuration and connectivity",
          "item": []
        }
      ]
    },
    {
      "name": "üîê Authentication",
      "description": "Complete authentication flows including basic auth and Google OAuth integration",
      "item": [
        {
          "name": "Basic Auth",
          "description": "Standard email/password authentication endpoints",
          "item": [
            {
              "name": "Login",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text",
                    "description": "Tenant identifier - required for all authentication requests"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"email\": \"{{testEmail}}\",\n  \"password\": \"{{testPassword}}\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/auth/login",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "auth",
                    "login"
                  ]
                },
                "description": "Authenticate a user with email and password. Returns a JWT access token that will be automatically captured for subsequent requests.\n\n**Required Headers:**\n- `x-tenant-id`: Tenant identifier\n- `Content-Type`: application/json\n\n**Request Body:**\n- `email`: User's email address\n- `password`: User's password\n\n**Response:**\n- `accessToken`: JWT token for authenticated requests\n\n**Rate Limiting:** 5 requests per minute\n\n**Example Scenarios:**\n- Valid credentials: Returns 200 with access token\n- Invalid credentials: Returns 401 Unauthorized\n- Missing tenant ID: Returns 400 Bad Request\n- Rate limit exceeded: Returns 429 Too Many Requests"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for login endpoint",
                      "",
                      "// Status code validation",
                      "pm.test('Login request returns successful status', function () {",
                      "    pm.expect(pm.response.code).to.be.oneOf([200, 201]);",
                      "});",
                      "",
                      "// Response time validation",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});",
                      "",
                      "// Content type validation",
                      "pm.test('Response content type is JSON', function () {",
                      "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                      "});",
                      "",
                      "// Response structure validation",
                      "pm.test('Response contains access token', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('accessToken');",
                      "    pm.expect(responseJson.accessToken).to.be.a('string');",
                      "    pm.expect(responseJson.accessToken.length).to.be.greaterThan(0);",
                      "});",
                      "",
                      "// Capture access token for subsequent requests",
                      "pm.test('Access token captured successfully', function () {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.accessToken) {",
                      "        pm.collectionVariables.set('accessToken', responseJson.accessToken);",
                      "        console.log('‚úÖ Access token captured and stored');",
                      "    }",
                      "});",
                      "",
                      "// Capture user ID if present in response",
                      "if (pm.response.code === 200) {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.user && responseJson.user.id) {",
                      "        pm.collectionVariables.set('userId', responseJson.user.id);",
                      "        console.log('‚úÖ User ID captured:', responseJson.user.id);",
                      "    }",
                      "}",
                      "",
                      "// Log authentication status",
                      "if (pm.response.code === 200) {",
                      "    console.log('üîê Authentication successful');",
                      "} else if (pm.response.code === 401) {",
                      "    console.log('‚ùå Authentication failed - Invalid credentials');",
                      "} else if (pm.response.code === 400) {",
                      "    console.log('‚ùå Bad request - Check tenant ID and request format');",
                      "} else if (pm.response.code === 429) {",
                      "    console.log('‚ö†Ô∏è Rate limit exceeded - Wait before retrying');",
                      "}"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for login",
                      "",
                      "// Ensure tenant ID is set",
                      "const tenantId = pm.collectionVariables.get('tenantId');",
                      "if (!tenantId) {",
                      "    console.log('‚ö†Ô∏è Warning: tenantId not set. Please set a tenant ID first.');",
                      "    console.log('üí° Tip: Register a tenant first or set tenantId manually');",
                      "}",
                      "",
                      "// Log request details",
                      "console.log('üîê Attempting login with:', {",
                      "    email: pm.collectionVariables.get('testEmail'),",
                      "    tenantId: tenantId",
                      "});",
                      "",
                      "// Clear any existing access token",
                      "pm.collectionVariables.set('accessToken', '');",
                      "console.log('üßπ Cleared existing access token');"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Login - Invalid Credentials Example",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"email\": \"invalid@example.com\",\n  \"password\": \"wrongpassword\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/auth/login",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "auth",
                    "login"
                  ]
                },
                "description": "Example of login attempt with invalid credentials. This request demonstrates error handling and should return a 401 Unauthorized response.\n\n**Expected Response:** 401 Unauthorized\n**Use Case:** Testing authentication error handling and security validation"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for invalid login attempt",
                      "",
                      "pm.test('Invalid credentials return 401 Unauthorized', function () {",
                      "    pm.expect(pm.response.code).to.equal(401);",
                      "});",
                      "",
                      "pm.test('Error response has proper structure', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('message');",
                      "});",
                      "",
                      "pm.test('No access token in error response', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.not.have.property('accessToken');",
                      "});",
                      "",
                      "console.log('‚úÖ Invalid credentials properly rejected');"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Login - Missing Tenant ID Example",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"email\": \"{{testEmail}}\",\n  \"password\": \"{{testPassword}}\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/auth/login",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "auth",
                    "login"
                  ]
                },
                "description": "Example of login attempt without tenant ID header. This request demonstrates tenant isolation validation and should return a 400 Bad Request response.\n\n**Expected Response:** 400 Bad Request\n**Use Case:** Testing tenant isolation and required header validation"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for missing tenant ID",
                      "",
                      "pm.test('Missing tenant ID returns 400 Bad Request', function () {",
                      "    pm.expect(pm.response.code).to.equal(400);",
                      "});",
                      "",
                      "pm.test('Error message mentions tenant ID requirement', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson.message.toLowerCase()).to.include('tenant');",
                      "});",
                      "",
                      "console.log('‚úÖ Tenant ID requirement properly enforced');"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Authentication Validation Suite",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"email\": \"{{testEmail}}\",\n  \"password\": \"{{testPassword}}\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/auth/login",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "auth",
                    "login"
                  ]
                },
                "description": "Comprehensive authentication validation suite that tests multiple aspects of the login endpoint including token validation, response time, security headers, and proper error handling.\n\n**Validation Coverage:**\n- Response time performance\n- JWT token format validation\n- Security headers presence\n- Rate limiting compliance\n- Error response structure\n- Token expiration validation\n\n**Use Case:** Complete authentication system validation and security testing"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Comprehensive Authentication Validation Suite",
                      "",
                      "// Performance validation",
                      "pm.test('Authentication response time is optimal', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(2000);",
                      "    if (pm.response.responseTime > 1000) {",
                      "        console.log('‚ö†Ô∏è Warning: Authentication took longer than 1 second');",
                      "    }",
                      "});",
                      "",
                      "// Security headers validation",
                      "pm.test('Security headers are present', function () {",
                      "    // Check for common security headers",
                      "    const headers = pm.response.headers;",
                      "    ",
                      "    // Content-Type should be JSON",
                      "    pm.expect(headers.get('Content-Type')).to.include('application/json');",
                      "    ",
                      "    // Log security header status",
                      "    console.log('üîí Security headers check:');",
                      "    console.log('  Content-Type:', headers.get('Content-Type') || 'Missing');",
                      "    console.log('  X-Frame-Options:', headers.get('X-Frame-Options') || 'Not set');",
                      "    console.log('  X-Content-Type-Options:', headers.get('X-Content-Type-Options') || 'Not set');",
                      "});",
                      "",
                      "// JWT token format validation",
                      "if (pm.response.code === 200) {",
                      "    pm.test('JWT token has valid format', function () {",
                      "        const responseJson = pm.response.json();",
                      "        const token = responseJson.accessToken;",
                      "        ",
                      "        // JWT should have 3 parts separated by dots",
                      "        const tokenParts = token.split('.');",
                      "        pm.expect(tokenParts).to.have.lengthOf(3);",
                      "        ",
                      "        // Each part should be base64 encoded",
                      "        tokenParts.forEach((part, index) => {",
                      "            pm.expect(part.length).to.be.greaterThan(0);",
                      "        });",
                      "        ",
                      "        console.log('‚úÖ JWT token format validation passed');",
                      "    });",
                      "    ",
                      "    pm.test('JWT token contains valid claims', function () {",
                      "        const responseJson = pm.response.json();",
                      "        const token = responseJson.accessToken;",
                      "        ",
                      "        try {",
                      "            // Decode JWT payload (without verification for testing)",
                      "            const payload = JSON.parse(atob(token.split('.')[1]));",
                      "            ",
                      "            // Check for required claims",
                      "            pm.expect(payload).to.have.property('sub'); // Subject (user ID)",
                      "            pm.expect(payload).to.have.property('iat'); // Issued at",
                      "            pm.expect(payload).to.have.property('exp'); // Expiration",
                      "            ",
                      "            // Validate expiration is in the future",
                      "            const now = Math.floor(Date.now() / 1000);",
                      "            pm.expect(payload.exp).to.be.greaterThan(now);",
                      "            ",
                      "            console.log('‚úÖ JWT claims validation passed');",
                      "            console.log('  Subject:', payload.sub);",
                      "            console.log('  Expires:', new Date(payload.exp * 1000).toISOString());",
                      "        } catch (error) {",
                      "            pm.expect.fail('Failed to decode JWT token: ' + error.message);",
                      "        }",
                      "    });",
                      "}",
                      "",
                      "// Rate limiting awareness",
                      "pm.test('Rate limiting headers check', function () {",
                      "    const headers = pm.response.headers;",
                      "    ",
                      "    // Log rate limiting information if available",
                      "    const rateLimitRemaining = headers.get('X-RateLimit-Remaining');",
                      "    const rateLimitReset = headers.get('X-RateLimit-Reset');",
                      "    ",
                      "    if (rateLimitRemaining) {",
                      "        console.log('üö¶ Rate limit remaining:', rateLimitRemaining);",
                      "        if (parseInt(rateLimitRemaining) < 2) {",
                      "            console.log('‚ö†Ô∏è Warning: Rate limit nearly exceeded');",
                      "        }",
                      "    }",
                      "    ",
                      "    if (rateLimitReset) {",
                      "        console.log('üïí Rate limit resets at:', new Date(parseInt(rateLimitReset) * 1000).toISOString());",
                      "    }",
                      "});",
                      "",
                      "// Error response validation for non-200 responses",
                      "if (pm.response.code !== 200) {",
                      "    pm.test('Error response has proper structure', function () {",
                      "        const responseJson = pm.response.json();",
                      "        ",
                      "        // Should have error message",
                      "        pm.expect(responseJson).to.have.property('message');",
                      "        pm.expect(responseJson.message).to.be.a('string');",
                      "        pm.expect(responseJson.message.length).to.be.greaterThan(0);",
                      "        ",
                      "        // Should not leak sensitive information",
                      "        const sensitiveTerms = ['password', 'secret', 'key', 'token', 'hash'];",
                      "        const message = responseJson.message.toLowerCase();",
                      "        sensitiveTerms.forEach(term => {",
                      "            pm.expect(message).to.not.include(term);",
                      "        });",
                      "        ",
                      "        console.log('‚úÖ Error response structure validated');",
                      "    });",
                      "}",
                      "",
                      "// Overall authentication status summary",
                      "const statusMessages = {",
                      "    200: 'üîê Authentication successful',",
                      "    400: '‚ùå Bad request - Check request format and tenant ID',",
                      "    401: '‚ùå Authentication failed - Invalid credentials',",
                      "    429: '‚ö†Ô∏è Rate limit exceeded - Wait before retrying',",
                      "    500: 'üö® Server error - Check system status'",
                      "};",
                      "",
                      "console.log(statusMessages[pm.response.code] || `‚ùì Unexpected status: ${pm.response.code}`);"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for comprehensive validation",
                      "",
                      "console.log('üß™ Running comprehensive authentication validation suite');",
                      "",
                      "// Log test environment",
                      "console.log('üìä Test Environment:');",
                      "console.log('  Base URL:', pm.collectionVariables.get('baseUrl'));",
                      "console.log('  Tenant ID:', pm.collectionVariables.get('tenantId'));",
                      "console.log('  Test Email:', pm.collectionVariables.get('testEmail'));",
                      "",
                      "// Clear any existing token for clean test",
                      "pm.collectionVariables.set('accessToken', '');",
                      "",
                      "// Record test start time",
                      "pm.collectionVariables.set('testStartTime', Date.now());"
                    ]
                  }
                }
              ]
            }
          ]
        },
        {
          "name": "Google OAuth Flow",
          "description": "Google OAuth 2.0 authentication flow endpoints",
          "item": [
            {
              "name": "1. Initiate Google OAuth",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text",
                    "description": "Tenant identifier - required to verify Google SSO is enabled"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/auth/google",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "auth",
                    "google"
                  ]
                },
                "description": "Initiates Google OAuth authentication flow. Returns authorization URL and state parameter for CSRF protection.\n\n**Required Headers:**\n- `x-tenant-id`: Tenant identifier\n\n**Response:**\n- `authUrl`: Google OAuth authorization URL\n- `state`: CSRF protection state parameter\n\n**Rate Limiting:** 10 requests per minute\n\n**Prerequisites:**\n- Tenant must have Google SSO enabled\n- Valid tenant ID must be provided\n\n**Next Steps:**\n1. Copy the `authUrl` from response\n2. Open URL in browser to authenticate with Google\n3. After Google authentication, copy the `code` parameter from callback URL\n4. Use the `code` and `state` in the callback endpoint\n\n**Example Flow:**\n1. GET /auth/google ‚Üí Returns authUrl and state\n2. User visits authUrl in browser\n3. User authenticates with Google\n4. Google redirects to callback with code\n5. POST /auth/google/callback with code and state"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Google OAuth initiation",
                      "",
                      "pm.test('OAuth initiation returns successful status', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response contains authorization URL', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('authUrl');",
                      "    pm.expect(responseJson.authUrl).to.be.a('string');",
                      "    pm.expect(responseJson.authUrl).to.include('accounts.google.com');",
                      "});",
                      "",
                      "pm.test('Response contains state parameter', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('state');",
                      "    pm.expect(responseJson.state).to.be.a('string');",
                      "    pm.expect(responseJson.state.length).to.be.greaterThan(10);",
                      "});",
                      "",
                      "// Capture OAuth parameters for callback",
                      "pm.test('OAuth parameters captured successfully', function () {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.authUrl && responseJson.state) {",
                      "        pm.collectionVariables.set('googleAuthUrl', responseJson.authUrl);",
                      "        pm.collectionVariables.set('googleState', responseJson.state);",
                      "        console.log('‚úÖ Google OAuth URL and state captured');",
                      "        console.log('üîó Authorization URL:', responseJson.authUrl);",
                      "        console.log('üîë State parameter:', responseJson.state);",
                      "    }",
                      "});",
                      "",
                      "// Instructions for manual OAuth flow",
                      "if (pm.response.code === 200) {",
                      "    const responseJson = pm.response.json();",
                      "    console.log('');",
                      "    console.log('üìã NEXT STEPS FOR GOOGLE OAUTH:');",
                      "    console.log('1. Copy this URL and open in browser:');",
                      "    console.log('   ' + responseJson.authUrl);",
                      "    console.log('2. Complete Google authentication');",
                      "    console.log('3. Copy the \"code\" parameter from the callback URL');",
                      "    console.log('4. Set the googleCode variable with that value');",
                      "    console.log('5. Run the \"Complete Google OAuth\" request');",
                      "}"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Google OAuth initiation",
                      "",
                      "// Ensure tenant ID is set",
                      "const tenantId = pm.collectionVariables.get('tenantId');",
                      "if (!tenantId) {",
                      "    console.log('‚ö†Ô∏è Warning: tenantId not set. Google OAuth requires a valid tenant.');",
                      "    console.log('üí° Tip: Register a tenant first or set tenantId manually');",
                      "}",
                      "",
                      "console.log('üîê Initiating Google OAuth flow for tenant:', tenantId);"
                    ]
                  }
                }
              ]
            },
            {
              "name": "2. Complete Google OAuth",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"code\": \"{{googleCode}}\",\n  \"state\": \"{{googleState}}\",\n  \"tenantId\": \"{{tenantId}}\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/auth/google/callback",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "auth",
                    "google",
                    "callback"
                  ]
                },
                "description": "Completes Google OAuth authentication flow. Exchanges authorization code for JWT token.\n\n**Required Body Parameters:**\n- `code`: Authorization code from Google OAuth callback\n- `state`: State parameter from OAuth initiation (for CSRF protection)\n- `tenantId`: Tenant identifier\n\n**Response:**\n- `accessToken`: JWT token for authenticated requests\n\n**Rate Limiting:** 10 requests per minute\n\n**Prerequisites:**\n1. Must have initiated OAuth flow with GET /auth/google\n2. Must have completed Google authentication in browser\n3. Must have valid authorization code from Google\n\n**Manual Setup Required:**\n- Set `googleCode` variable with the authorization code from Google's callback URL\n- The `state` and `tenantId` are automatically populated from previous requests\n\n**Error Scenarios:**\n- Invalid/expired state: 400 Bad Request\n- Invalid authorization code: 401 Unauthorized\n- Google SSO disabled: 403 Forbidden\n- User not allowed in tenant: 403 Forbidden"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Google OAuth callback",
                      "",
                      "pm.test('OAuth callback returns successful status', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response contains access token', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('accessToken');",
                      "    pm.expect(responseJson.accessToken).to.be.a('string');",
                      "    pm.expect(responseJson.accessToken.length).to.be.greaterThan(0);",
                      "});",
                      "",
                      "// Capture access token for subsequent requests",
                      "pm.test('Access token captured successfully', function () {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.accessToken) {",
                      "        pm.collectionVariables.set('accessToken', responseJson.accessToken);",
                      "        console.log('‚úÖ Google OAuth access token captured and stored');",
                      "    }",
                      "});",
                      "",
                      "// Capture user information if present",
                      "if (pm.response.code === 200) {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.user && responseJson.user.id) {",
                      "        pm.collectionVariables.set('userId', responseJson.user.id);",
                      "        console.log('‚úÖ User ID captured:', responseJson.user.id);",
                      "    }",
                      "}",
                      "",
                      "// Clear OAuth temporary variables",
                      "if (pm.response.code === 200) {",
                      "    pm.collectionVariables.set('googleCode', '');",
                      "    console.log('üßπ Cleared temporary OAuth variables');",
                      "}",
                      "",
                      "// Log authentication status",
                      "if (pm.response.code === 200) {",
                      "    console.log('üîê Google OAuth authentication successful');",
                      "} else if (pm.response.code === 400) {",
                      "    console.log('‚ùå Bad request - Check state parameter and authorization code');",
                      "} else if (pm.response.code === 401) {",
                      "    console.log('‚ùå Unauthorized - Invalid authorization code or expired state');",
                      "} else if (pm.response.code === 403) {",
                      "    console.log('‚ùå Forbidden - Google SSO disabled or user not allowed');",
                      "}"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Google OAuth callback",
                      "",
                      "// Check required variables",
                      "const googleCode = pm.collectionVariables.get('googleCode');",
                      "const googleState = pm.collectionVariables.get('googleState');",
                      "const tenantId = pm.collectionVariables.get('tenantId');",
                      "",
                      "if (!googleCode) {",
                      "    console.log('‚ö†Ô∏è Warning: googleCode not set. You need to:');",
                      "    console.log('1. Run \"Initiate Google OAuth\" first');",
                      "    console.log('2. Complete authentication in browser');",
                      "    console.log('3. Set googleCode variable from callback URL');",
                      "}",
                      "",
                      "if (!googleState) {",
                      "    console.log('‚ö†Ô∏è Warning: googleState not set. Run \"Initiate Google OAuth\" first.');",
                      "}",
                      "",
                      "if (!tenantId) {",
                      "    console.log('‚ö†Ô∏è Warning: tenantId not set. Set tenant ID first.');",
                      "}",
                      "",
                      "console.log('üîê Completing Google OAuth with:', {",
                      "    hasCode: !!googleCode,",
                      "    hasState: !!googleState,",
                      "    tenantId: tenantId",
                      "});"
                    ]
                  }
                }
              ]
            }
          ]
        },
        {
          "name": "Account Linking",
          "description": "Link and unlink Google accounts with existing users",
          "item": [
            {
              "name": "1. Initiate Google Account Linking",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text",
                    "description": "JWT token for authenticated user"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/auth/google/link",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "auth",
                    "google",
                    "link"
                  ]
                },
                "description": "Initiates Google account linking flow for authenticated users. Returns authorization URL and state parameter.\n\n**Authentication Required:** Yes (Bearer token)\n\n**Response:**\n- `authUrl`: Google OAuth authorization URL for linking\n- `state`: CSRF protection state parameter (includes user ID)\n\n**Rate Limiting:** 5 requests per minute\n\n**Prerequisites:**\n- User must be authenticated (valid access token)\n- User must not already have Google account linked\n\n**Use Cases:**\n- Link Google account to existing password-based account\n- Add Google as additional authentication method\n- Enable Google SSO for existing users\n\n**Next Steps:**\n1. Copy the `authUrl` from response\n2. Open URL in browser to authenticate with Google\n3. After Google authentication, copy the `code` parameter from callback URL\n4. Use the `code` and `state` in the link callback endpoint"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Google account linking initiation",
                      "",
                      "pm.test('Account linking initiation returns successful status', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response contains authorization URL', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('authUrl');",
                      "    pm.expect(responseJson.authUrl).to.be.a('string');",
                      "    pm.expect(responseJson.authUrl).to.include('accounts.google.com');",
                      "});",
                      "",
                      "pm.test('Response contains state parameter', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('state');",
                      "    pm.expect(responseJson.state).to.be.a('string');",
                      "    pm.expect(responseJson.state.length).to.be.greaterThan(10);",
                      "});",
                      "",
                      "// Capture linking parameters",
                      "pm.test('Linking parameters captured successfully', function () {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.authUrl && responseJson.state) {",
                      "        pm.collectionVariables.set('googleLinkUrl', responseJson.authUrl);",
                      "        pm.collectionVariables.set('googleLinkState', responseJson.state);",
                      "        console.log('‚úÖ Google linking URL and state captured');",
                      "        console.log('üîó Linking URL:', responseJson.authUrl);",
                      "    }",
                      "});",
                      "",
                      "// Instructions for manual linking flow",
                      "if (pm.response.code === 200) {",
                      "    const responseJson = pm.response.json();",
                      "    console.log('');",
                      "    console.log('üìã NEXT STEPS FOR GOOGLE ACCOUNT LINKING:');",
                      "    console.log('1. Copy this URL and open in browser:');",
                      "    console.log('   ' + responseJson.authUrl);",
                      "    console.log('2. Complete Google authentication');",
                      "    console.log('3. Copy the \"code\" parameter from the callback URL');",
                      "    console.log('4. Set the googleLinkCode variable with that value');",
                      "    console.log('5. Run the \"Complete Google Account Linking\" request');",
                      "}"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Google account linking",
                      "",
                      "// Check authentication",
                      "const accessToken = pm.collectionVariables.get('accessToken');",
                      "if (!accessToken) {",
                      "    console.log('‚ö†Ô∏è Warning: No access token found. Please login first.');",
                      "}",
                      "",
                      "console.log('üîó Initiating Google account linking for authenticated user');"
                    ]
                  }
                }
              ]
            },
            {
              "name": "2. Complete Google Account Linking",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text",
                    "description": "JWT token for authenticated user"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"code\": \"{{googleLinkCode}}\",\n  \"state\": \"{{googleLinkState}}\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/auth/google/link/callback",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "auth",
                    "google",
                    "link",
                    "callback"
                  ]
                },
                "description": "Completes Google account linking flow. Links Google account to authenticated user.\n\n**Authentication Required:** Yes (Bearer token)\n\n**Required Body Parameters:**\n- `code`: Authorization code from Google OAuth callback\n- `state`: State parameter from linking initiation (includes user ID)\n\n**Response:**\n- `message`: Success confirmation message\n\n**Rate Limiting:** 5 requests per minute\n\n**Prerequisites:**\n1. Must be authenticated with valid access token\n2. Must have initiated linking flow with GET /auth/google/link\n3. Must have completed Google authentication in browser\n4. Must have valid authorization code from Google\n\n**Manual Setup Required:**\n- Set `googleLinkCode` variable with the authorization code from Google's callback URL\n- The `state` is automatically populated from the linking initiation request\n\n**Validation Rules:**\n- Google email must match user's current email\n- Google account must not be linked to another user\n- State parameter must be valid and include correct user ID\n\n**Error Scenarios:**\n- Email mismatch: 400 Bad Request\n- Google account already linked: 409 Conflict\n- Invalid state: 400 Bad Request\n- Invalid authorization code: 401 Unauthorized"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Google account linking completion",
                      "",
                      "pm.test('Account linking returns successful status', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response contains success message', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('message');",
                      "    pm.expect(responseJson.message).to.include('linked successfully');",
                      "});",
                      "",
                      "// Clear linking temporary variables",
                      "if (pm.response.code === 200) {",
                      "    pm.collectionVariables.set('googleLinkCode', '');",
                      "    pm.collectionVariables.set('googleLinkUrl', '');",
                      "    console.log('‚úÖ Google account linked successfully');",
                      "    console.log('üßπ Cleared temporary linking variables');",
                      "}",
                      "",
                      "// Log linking status",
                      "if (pm.response.code === 200) {",
                      "    console.log('üîó Google account linking completed successfully');",
                      "} else if (pm.response.code === 400) {",
                      "    console.log('‚ùå Bad request - Check email match and state parameter');",
                      "} else if (pm.response.code === 409) {",
                      "    console.log('‚ùå Conflict - Google account already linked to another user');",
                      "} else if (pm.response.code === 401) {",
                      "    console.log('‚ùå Unauthorized - Invalid authorization code or state');",
                      "}"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Google account linking completion",
                      "",
                      "// Check required variables",
                      "const accessToken = pm.collectionVariables.get('accessToken');",
                      "const googleLinkCode = pm.collectionVariables.get('googleLinkCode');",
                      "const googleLinkState = pm.collectionVariables.get('googleLinkState');",
                      "",
                      "if (!accessToken) {",
                      "    console.log('‚ö†Ô∏è Warning: No access token found. Please login first.');",
                      "}",
                      "",
                      "if (!googleLinkCode) {",
                      "    console.log('‚ö†Ô∏è Warning: googleLinkCode not set. You need to:');",
                      "    console.log('1. Run \"Initiate Google Account Linking\" first');",
                      "    console.log('2. Complete authentication in browser');",
                      "    console.log('3. Set googleLinkCode variable from callback URL');",
                      "}",
                      "",
                      "if (!googleLinkState) {",
                      "    console.log('‚ö†Ô∏è Warning: googleLinkState not set. Run linking initiation first.');",
                      "}",
                      "",
                      "console.log('üîó Completing Google account linking with:', {",
                      "    hasToken: !!accessToken,",
                      "    hasCode: !!googleLinkCode,",
                      "    hasState: !!googleLinkState",
                      "});"
                    ]
                  }
                }
              ]
            },
            {
              "name": "3. Unlink Google Account",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text",
                    "description": "JWT token for authenticated user"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/auth/google/unlink",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "auth",
                    "google",
                    "unlink"
                  ]
                },
                "description": "Unlinks Google account from authenticated user. Requires at least one other authentication method.\n\n**Authentication Required:** Yes (Bearer token)\n\n**Response:**\n- `message`: Success confirmation message\n\n**Rate Limiting:** 5 requests per minute\n\n**Prerequisites:**\n- User must be authenticated with valid access token\n- User must have Google account linked\n- User must have at least one other authentication method (password)\n\n**Security Rules:**\n- Cannot unlink if it's the only authentication method\n- User must maintain at least one way to authenticate\n\n**Use Cases:**\n- Remove Google authentication method\n- Security cleanup when changing authentication preferences\n- Account security management\n\n**Error Scenarios:**\n- Google account not linked: 404 Not Found\n- Only authentication method: 400 Bad Request\n- Not authenticated: 401 Unauthorized"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Google account unlinking",
                      "",
                      "pm.test('Account unlinking returns successful status', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response contains success message', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('message');",
                      "    pm.expect(responseJson.message).to.include('unlinked successfully');",
                      "});",
                      "",
                      "// Log unlinking status",
                      "if (pm.response.code === 200) {",
                      "    console.log('üîì Google account unlinked successfully');",
                      "} else if (pm.response.code === 400) {",
                      "    console.log('‚ùå Bad request - Cannot unlink only authentication method');",
                      "} else if (pm.response.code === 404) {",
                      "    console.log('‚ùå Not found - Google account not linked to this user');",
                      "} else if (pm.response.code === 401) {",
                      "    console.log('‚ùå Unauthorized - Authentication required');",
                      "}"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Google account unlinking",
                      "",
                      "// Check authentication",
                      "const accessToken = pm.collectionVariables.get('accessToken');",
                      "if (!accessToken) {",
                      "    console.log('‚ö†Ô∏è Warning: No access token found. Please login first.');",
                      "}",
                      "",
                      "console.log('üîì Unlinking Google account for authenticated user');"
                    ]
                  }
                }
              ]
            }
          ]
        },
        {
          "name": "Auth Management",
          "description": "Manage authentication methods and user auth status",
          "item": [
            {
              "name": "Get User Authentication Methods",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text",
                    "description": "JWT token for authenticated user"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/auth/me/auth-methods",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "auth",
                    "me",
                    "auth-methods"
                  ]
                },
                "description": "Returns the available authentication methods for the authenticated user.\n\n**Authentication Required:** Yes (Bearer token)\n\n**Response:**\n- `authMethods`: Array of available authentication methods\n\n**Possible Authentication Methods:**\n- `password`: Email/password authentication\n- `google`: Google OAuth authentication\n\n**Use Cases:**\n- Check which authentication methods are available\n- Determine if user can unlink Google account\n- Display authentication options in UI\n- Security audit of user authentication methods\n\n**Example Response:**\n```json\n{\n  \"authMethods\": [\"password\", \"google\"]\n}\n```\n\n**Security Notes:**\n- Users must have at least one authentication method\n- This endpoint helps prevent users from removing their only auth method"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for authentication methods endpoint",
                      "",
                      "pm.test('Auth methods request returns successful status', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response contains auth methods array', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('authMethods');",
                      "    pm.expect(responseJson.authMethods).to.be.an('array');",
                      "});",
                      "",
                      "pm.test('Auth methods array is not empty', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson.authMethods.length).to.be.greaterThan(0);",
                      "});",
                      "",
                      "pm.test('Auth methods contain valid values', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const validMethods = ['password', 'google'];",
                      "    responseJson.authMethods.forEach(method => {",
                      "        pm.expect(validMethods).to.include(method);",
                      "    });",
                      "});",
                      "",
                      "// Log authentication methods",
                      "if (pm.response.code === 200) {",
                      "    const responseJson = pm.response.json();",
                      "    console.log('üîê Available authentication methods:', responseJson.authMethods);",
                      "    ",
                      "    // Check if user can safely unlink Google",
                      "    if (responseJson.authMethods.includes('google') && responseJson.authMethods.length > 1) {",
                      "        console.log('‚úÖ User can safely unlink Google account (has other auth methods)');",
                      "    } else if (responseJson.authMethods.includes('google') && responseJson.authMethods.length === 1) {",
                      "        console.log('‚ö†Ô∏è User cannot unlink Google account (only auth method)');",
                      "    }",
                      "} else if (pm.response.code === 401) {",
                      "    console.log('‚ùå Unauthorized - Authentication required');",
                      "} else if (pm.response.code === 404) {",
                      "    console.log('‚ùå Not found - User not found');",
                      "}"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for authentication methods",
                      "",
                      "// Check authentication",
                      "const accessToken = pm.collectionVariables.get('accessToken');",
                      "if (!accessToken) {",
                      "    console.log('‚ö†Ô∏è Warning: No access token found. Please login first.');",
                      "}",
                      "",
                      "console.log('üîç Retrieving authentication methods for current user');"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "üè¢ Tenant Management",
      "description": "Tenant registration and Google SSO configuration management",
      "item": [
        {
          "name": "Tenant Registration",
          "description": "Register new tenants and manage tenant lifecycle",
          "item": [
            {
              "name": "Register New Tenant",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"tenantName\": \"Acme Corporation\",\n  \"adminEmail\": \"admin@acme.com\",\n  \"adminPassword\": \"SecurePass123!\",\n  \"adminFirstName\": \"John\",\n  \"adminLastName\": \"Doe\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/tenants",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "tenants"
                  ]
                },
                "description": "Register a new tenant with an admin user, default roles, and permissions. This endpoint does not require authentication and creates the complete tenant infrastructure.\n\n**Public Endpoint:** No authentication required\n\n**Request Body:**\n- `tenantName`: Organization name (2-100 characters)\n- `adminEmail`: Administrator email address\n- `adminPassword`: Strong password (min 8 chars, uppercase, lowercase, number/special char)\n- `adminFirstName`: Administrator first name (2-50 characters)\n- `adminLastName`: Administrator last name (2-50 characters)\n\n**Response:**\n- `tenant`: Created tenant information with ID\n- `adminUser`: Created admin user information\n\n**Success Response:** 201 Created\n**Error Responses:**\n- 409 Conflict: Email or tenant name already exists\n- 400 Bad Request: Invalid input data\n\n**Use Cases:**\n- Initial tenant setup for new organizations\n- Multi-tenant application onboarding\n- Admin user provisioning"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for tenant registration",
                      "",
                      "// Status code validation",
                      "pm.test('Tenant registration returns 201 Created', function () {",
                      "    pm.expect(pm.response.code).to.equal(201);",
                      "});",
                      "",
                      "// Response time validation",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(5000);",
                      "});",
                      "",
                      "// Content type validation",
                      "pm.test('Response content type is JSON', function () {",
                      "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                      "});",
                      "",
                      "// Response structure validation",
                      "pm.test('Response has correct structure', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('message');",
                      "    pm.expect(responseJson).to.have.property('data');",
                      "    pm.expect(responseJson.data).to.have.property('tenant');",
                      "    pm.expect(responseJson.data).to.have.property('adminUser');",
                      "});",
                      "",
                      "// Tenant data validation",
                      "pm.test('Tenant data is properly structured', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const tenant = responseJson.data.tenant;",
                      "    ",
                      "    pm.expect(tenant).to.have.property('id');",
                      "    pm.expect(tenant).to.have.property('name');",
                      "    pm.expect(tenant).to.have.property('createdAt');",
                      "    pm.expect(tenant).to.have.property('updatedAt');",
                      "    ",
                      "    // Validate tenant ID format (UUID)",
                      "    pm.expect(tenant.id).to.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i);",
                      "});",
                      "",
                      "// Admin user data validation",
                      "pm.test('Admin user data is properly structured', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const adminUser = responseJson.data.adminUser;",
                      "    ",
                      "    pm.expect(adminUser).to.have.property('id');",
                      "    pm.expect(adminUser).to.have.property('email');",
                      "    pm.expect(adminUser).to.have.property('firstName');",
                      "    pm.expect(adminUser).to.have.property('lastName');",
                      "    pm.expect(adminUser).to.have.property('tenantId');",
                      "    ",
                      "    // Validate user ID format (UUID)",
                      "    pm.expect(adminUser.id).to.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i);",
                      "    ",
                      "    // Validate email format",
                      "    pm.expect(adminUser.email).to.match(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/);",
                      "});",
                      "",
                      "// Capture tenant ID for subsequent requests",
                      "pm.test('Tenant ID captured successfully', function () {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.data && responseJson.data.tenant && responseJson.data.tenant.id) {",
                      "        pm.collectionVariables.set('tenantId', responseJson.data.tenant.id);",
                      "        console.log('‚úÖ Tenant ID captured:', responseJson.data.tenant.id);",
                      "    }",
                      "});",
                      "",
                      "// Capture admin user ID for subsequent requests",
                      "pm.test('Admin user ID captured successfully', function () {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.data && responseJson.data.adminUser && responseJson.data.adminUser.id) {",
                      "        pm.collectionVariables.set('adminUserId', responseJson.data.adminUser.id);",
                      "        pm.collectionVariables.set('userId', responseJson.data.adminUser.id);",
                      "        console.log('‚úÖ Admin user ID captured:', responseJson.data.adminUser.id);",
                      "    }",
                      "});",
                      "",
                      "// Security validation - no sensitive data in response",
                      "pm.test('Response does not contain sensitive data', function () {",
                      "    const responseText = pm.response.text().toLowerCase();",
                      "    pm.expect(responseText).to.not.include('password');",
                      "    pm.expect(responseText).to.not.include('secret');",
                      "    pm.expect(responseText).to.not.include('private');",
                      "});",
                      "",
                      "// Log registration status",
                      "if (pm.response.code === 201) {",
                      "    const responseJson = pm.response.json();",
                      "    console.log('üè¢ Tenant registration successful');",
                      "    console.log('  Tenant:', responseJson.data.tenant.name);",
                      "    console.log('  Admin:', responseJson.data.adminUser.email);",
                      "} else if (pm.response.code === 409) {",
                      "    console.log('‚ùå Conflict - Email or tenant name already exists');",
                      "} else if (pm.response.code === 400) {",
                      "    console.log('‚ùå Bad request - Check input validation');",
                      "}"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for tenant registration",
                      "",
                      "// Generate unique tenant name and email to avoid conflicts",
                      "const timestamp = Date.now();",
                      "const randomSuffix = Math.random().toString(36).substring(2, 8);",
                      "",
                      "// Update request body with unique values",
                      "const requestBody = JSON.parse(pm.request.body.raw);",
                      "requestBody.tenantName = `Test Tenant ${timestamp}`;",
                      "requestBody.adminEmail = `admin-${randomSuffix}@test-${timestamp}.com`;",
                      "",
                      "// Update the request body",
                      "pm.request.body.raw = JSON.stringify(requestBody, null, 2);",
                      "",
                      "console.log('üè¢ Registering tenant with unique identifiers:');",
                      "console.log('  Tenant Name:', requestBody.tenantName);",
                      "console.log('  Admin Email:', requestBody.adminEmail);",
                      "",
                      "// Clear any existing tenant context",
                      "pm.collectionVariables.set('tenantId', '');",
                      "pm.collectionVariables.set('adminUserId', '');",
                      "console.log('üßπ Cleared existing tenant context');"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Register Tenant - Conflict Example",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"tenantName\": \"Acme Corporation\",\n  \"adminEmail\": \"admin@acme.com\",\n  \"adminPassword\": \"SecurePass123!\",\n  \"adminFirstName\": \"John\",\n  \"adminLastName\": \"Doe\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/tenants",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "tenants"
                  ]
                },
                "description": "Example of tenant registration with duplicate data. This request demonstrates conflict handling when trying to register a tenant with an existing email or tenant name.\n\n**Expected Response:** 409 Conflict\n**Use Case:** Testing duplicate detection and error handling\n\n**Conflict Scenarios:**\n- Duplicate tenant name\n- Duplicate admin email address\n- Database constraint violations"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for conflict handling",
                      "",
                      "pm.test('Duplicate registration returns 409 Conflict', function () {",
                      "    pm.expect(pm.response.code).to.equal(409);",
                      "});",
                      "",
                      "pm.test('Conflict response has proper error message', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('message');",
                      "    pm.expect(responseJson.message).to.be.a('string');",
                      "    pm.expect(responseJson.message.length).to.be.greaterThan(0);",
                      "});",
                      "",
                      "pm.test('Error message indicates conflict type', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const message = responseJson.message.toLowerCase();",
                      "    const hasConflictInfo = message.includes('email') || message.includes('tenant') || message.includes('exists') || message.includes('duplicate');",
                      "    pm.expect(hasConflictInfo).to.be.true;",
                      "});",
                      "",
                      "console.log('‚úÖ Conflict handling properly implemented');"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Register Tenant - Validation Error Example",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"tenantName\": \"A\",\n  \"adminEmail\": \"invalid-email\",\n  \"adminPassword\": \"weak\",\n  \"adminFirstName\": \"\",\n  \"adminLastName\": \"D\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/tenants",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "tenants"
                  ]
                },
                "description": "Example of tenant registration with invalid data. This request demonstrates input validation and error handling for malformed or insufficient data.\n\n**Expected Response:** 400 Bad Request\n**Use Case:** Testing input validation and error messages\n\n**Validation Errors:**\n- Tenant name too short (min 2 characters)\n- Invalid email format\n- Weak password (doesn't meet complexity requirements)\n- Empty first name\n- Last name too short"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for validation error handling",
                      "",
                      "pm.test('Invalid data returns 400 Bad Request', function () {",
                      "    pm.expect(pm.response.code).to.equal(400);",
                      "});",
                      "",
                      "pm.test('Validation error response has proper structure', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('message');",
                      "    // May also have 'errors' array for detailed validation messages",
                      "});",
                      "",
                      "pm.test('Error message indicates validation failure', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const message = responseJson.message.toLowerCase();",
                      "    const hasValidationInfo = message.includes('validation') || message.includes('invalid') || message.includes('required') || message.includes('format');",
                      "    pm.expect(hasValidationInfo).to.be.true;",
                      "});",
                      "",
                      "console.log('‚úÖ Input validation properly implemented');"
                    ]
                  }
                }
              ]
            }
          ]
        },
        {
          "name": "Google SSO Settings",
          "description": "Configure and manage Google SSO settings for tenants",
          "item": [
            {
              "name": "Get Google SSO Settings",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text",
                    "description": "Tenant identifier for isolation"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/tenants/{{tenantId}}/settings/google",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "tenants",
                    "{{tenantId}}",
                    "settings",
                    "google"
                  ]
                },
                "description": "Retrieve current Google SSO configuration for the specified tenant. This endpoint requires admin role authentication.\n\n**Authentication:** Bearer token required\n**Authorization:** Admin role required\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n\n**Path Parameters:**\n- `id`: Tenant ID (UUID)\n\n**Response:**\n- `googleSsoEnabled`: Boolean indicating if Google SSO is enabled\n- `googleAutoProvision`: Boolean indicating if auto-provisioning is enabled\n\n**Success Response:** 200 OK\n**Error Responses:**\n- 401 Unauthorized: Missing or invalid token\n- 403 Forbidden: Admin role required\n- 404 Not Found: Tenant not found\n\n**Use Cases:**\n- Check current Google SSO configuration\n- Admin dashboard settings display\n- Configuration validation before updates"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for getting Google SSO settings",
                      "",
                      "// Status code validation",
                      "pm.test('Get Google SSO settings returns 200 OK', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "// Response time validation",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(2000);",
                      "});",
                      "",
                      "// Content type validation",
                      "pm.test('Response content type is JSON', function () {",
                      "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                      "});",
                      "",
                      "// Response structure validation",
                      "pm.test('Response has correct Google SSO settings structure', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('googleSsoEnabled');",
                      "    pm.expect(responseJson).to.have.property('googleAutoProvision');",
                      "});",
                      "",
                      "// Data type validation",
                      "pm.test('Google SSO settings have correct data types', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson.googleSsoEnabled).to.be.a('boolean');",
                      "    pm.expect(responseJson.googleAutoProvision).to.be.a('boolean');",
                      "});",
                      "",
                      "// Store current settings for comparison in update tests",
                      "if (pm.response.code === 200) {",
                      "    const responseJson = pm.response.json();",
                      "    pm.collectionVariables.set('currentGoogleSsoEnabled', responseJson.googleSsoEnabled.toString());",
                      "    pm.collectionVariables.set('currentGoogleAutoProvision', responseJson.googleAutoProvision.toString());",
                      "    console.log('‚úÖ Current Google SSO settings captured:');",
                      "    console.log('  SSO Enabled:', responseJson.googleSsoEnabled);",
                      "    console.log('  Auto Provision:', responseJson.googleAutoProvision);",
                      "}",
                      "",
                      "// Log access status",
                      "if (pm.response.code === 200) {",
                      "    console.log('üîß Google SSO settings retrieved successfully');",
                      "} else if (pm.response.code === 403) {",
                      "    console.log('‚ùå Access denied - Admin role required');",
                      "} else if (pm.response.code === 404) {",
                      "    console.log('‚ùå Tenant not found');",
                      "} else if (pm.response.code === 401) {",
                      "    console.log('‚ùå Authentication required');",
                      "}"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for getting Google SSO settings",
                      "",
                      "// Validate required variables",
                      "const tenantId = pm.collectionVariables.get('tenantId');",
                      "const accessToken = pm.collectionVariables.get('accessToken');",
                      "",
                      "if (!tenantId) {",
                      "    console.log('‚ö†Ô∏è Warning: tenantId not set. Please register a tenant first.');",
                      "}",
                      "",
                      "if (!accessToken) {",
                      "    console.log('‚ö†Ô∏è Warning: accessToken not set. Please authenticate first.');",
                      "}",
                      "",
                      "console.log('üîß Retrieving Google SSO settings for tenant:', tenantId);"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Update Google SSO Settings",
              "request": {
                "method": "PATCH",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text",
                    "description": "Tenant identifier for isolation"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"googleSsoEnabled\": true,\n  \"googleAutoProvision\": false\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/tenants/{{tenantId}}/settings/google",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "tenants",
                    "{{tenantId}}",
                    "settings",
                    "google"
                  ]
                },
                "description": "Update Google SSO configuration for the specified tenant. This endpoint requires admin role authentication and allows partial updates.\n\n**Authentication:** Bearer token required\n**Authorization:** Admin role required\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n- `Content-Type`: application/json\n\n**Path Parameters:**\n- `id`: Tenant ID (UUID)\n\n**Request Body (all fields optional):**\n- `googleSsoEnabled`: Enable/disable Google SSO for the tenant\n- `googleAutoProvision`: Enable/disable automatic user provisioning\n\n**Response:**\n- `message`: Success message\n- `data`: Updated tenant information with new settings\n\n**Success Response:** 200 OK\n**Error Responses:**\n- 401 Unauthorized: Missing or invalid token\n- 403 Forbidden: Admin role required\n- 404 Not Found: Tenant not found\n- 400 Bad Request: Invalid input data\n\n**Use Cases:**\n- Enable/disable Google SSO for organization\n- Configure auto-provisioning behavior\n- Admin settings management"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for updating Google SSO settings",
                      "",
                      "// Status code validation",
                      "pm.test('Update Google SSO settings returns 200 OK', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "// Response time validation",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});",
                      "",
                      "// Content type validation",
                      "pm.test('Response content type is JSON', function () {",
                      "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                      "});",
                      "",
                      "// Response structure validation",
                      "pm.test('Response has correct structure', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('message');",
                      "    pm.expect(responseJson).to.have.property('data');",
                      "});",
                      "",
                      "// Updated data validation",
                      "pm.test('Updated tenant data is properly structured', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const data = responseJson.data;",
                      "    ",
                      "    pm.expect(data).to.have.property('id');",
                      "    pm.expect(data).to.have.property('name');",
                      "    pm.expect(data).to.have.property('googleSsoEnabled');",
                      "    pm.expect(data).to.have.property('googleAutoProvision');",
                      "    pm.expect(data).to.have.property('updatedAt');",
                      "    ",
                      "    // Validate data types",
                      "    pm.expect(data.googleSsoEnabled).to.be.a('boolean');",
                      "    pm.expect(data.googleAutoProvision).to.be.a('boolean');",
                      "});",
                      "",
                      "// Validate settings were actually updated",
                      "pm.test('Settings were updated correctly', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const requestBody = JSON.parse(pm.request.body.raw);",
                      "    const updatedData = responseJson.data;",
                      "    ",
                      "    // Check if the settings match what was requested",
                      "    if (requestBody.hasOwnProperty('googleSsoEnabled')) {",
                      "        pm.expect(updatedData.googleSsoEnabled).to.equal(requestBody.googleSsoEnabled);",
                      "    }",
                      "    ",
                      "    if (requestBody.hasOwnProperty('googleAutoProvision')) {",
                      "        pm.expect(updatedData.googleAutoProvision).to.equal(requestBody.googleAutoProvision);",
                      "    }",
                      "});",
                      "",
                      "// Validate updatedAt timestamp is recent",
                      "pm.test('UpdatedAt timestamp is recent', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const updatedAt = new Date(responseJson.data.updatedAt);",
                      "    const now = new Date();",
                      "    const timeDiff = now - updatedAt;",
                      "    ",
                      "    // Should be updated within the last 10 seconds",
                      "    pm.expect(timeDiff).to.be.below(10000);",
                      "});",
                      "",
                      "// Log update status",
                      "if (pm.response.code === 200) {",
                      "    const responseJson = pm.response.json();",
                      "    console.log('üîß Google SSO settings updated successfully');",
                      "    console.log('  SSO Enabled:', responseJson.data.googleSsoEnabled);",
                      "    console.log('  Auto Provision:', responseJson.data.googleAutoProvision);",
                      "    console.log('  Updated At:', responseJson.data.updatedAt);",
                      "} else if (pm.response.code === 403) {",
                      "    console.log('‚ùå Access denied - Admin role required');",
                      "} else if (pm.response.code === 404) {",
                      "    console.log('‚ùå Tenant not found');",
                      "} else if (pm.response.code === 401) {",
                      "    console.log('‚ùå Authentication required');",
                      "} else if (pm.response.code === 400) {",
                      "    console.log('‚ùå Bad request - Check input data');",
                      "}"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for updating Google SSO settings",
                      "",
                      "// Validate required variables",
                      "const tenantId = pm.collectionVariables.get('tenantId');",
                      "const accessToken = pm.collectionVariables.get('accessToken');",
                      "",
                      "if (!tenantId) {",
                      "    console.log('‚ö†Ô∏è Warning: tenantId not set. Please register a tenant first.');",
                      "}",
                      "",
                      "if (!accessToken) {",
                      "    console.log('‚ö†Ô∏è Warning: accessToken not set. Please authenticate with admin role first.');",
                      "}",
                      "",
                      "// Log the update request",
                      "const requestBody = JSON.parse(pm.request.body.raw);",
                      "console.log('üîß Updating Google SSO settings for tenant:', tenantId);",
                      "console.log('  New settings:', requestBody);"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Update Google SSO Settings - Enable SSO Only",
              "request": {
                "method": "PATCH",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"googleSsoEnabled\": true\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/tenants/{{tenantId}}/settings/google",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "tenants",
                    "{{tenantId}}",
                    "settings",
                    "google"
                  ]
                },
                "description": "Example of partial update - enable Google SSO only without changing auto-provisioning settings. Demonstrates that the PATCH endpoint supports partial updates.\n\n**Use Case:** Enable Google SSO while keeping existing auto-provisioning setting\n**Update Type:** Partial update (only googleSsoEnabled field)"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for partial update",
                      "",
                      "pm.test('Partial update returns 200 OK', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Only specified field was updated', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const updatedData = responseJson.data;",
                      "    ",
                      "    // googleSsoEnabled should be true",
                      "    pm.expect(updatedData.googleSsoEnabled).to.be.true;",
                      "    ",
                      "    // googleAutoProvision should remain unchanged",
                      "    pm.expect(updatedData).to.have.property('googleAutoProvision');",
                      "});",
                      "",
                      "console.log('‚úÖ Partial update (SSO enabled) completed successfully');"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Update Google SSO Settings - Disable All",
              "request": {
                "method": "PATCH",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"googleSsoEnabled\": false,\n  \"googleAutoProvision\": false\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/tenants/{{tenantId}}/settings/google",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "tenants",
                    "{{tenantId}}",
                    "settings",
                    "google"
                  ]
                },
                "description": "Example of disabling all Google SSO features for a tenant. This configuration disables both Google SSO and auto-provisioning.\n\n**Use Case:** Completely disable Google integration for security or policy reasons\n**Security Impact:** Users will need to use email/password authentication only"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for disabling Google SSO",
                      "",
                      "pm.test('Google SSO disabled successfully', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Both Google features are disabled', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const updatedData = responseJson.data;",
                      "    ",
                      "    pm.expect(updatedData.googleSsoEnabled).to.be.false;",
                      "    pm.expect(updatedData.googleAutoProvision).to.be.false;",
                      "});",
                      "",
                      "console.log('‚úÖ Google SSO completely disabled');"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Get Google SSO Settings - Unauthorized Example",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/tenants/{{tenantId}}/settings/google",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "tenants",
                    "{{tenantId}}",
                    "settings",
                    "google"
                  ]
                },
                "description": "Example of accessing Google SSO settings without authentication. This request demonstrates security validation and should return a 401 Unauthorized response.\n\n**Expected Response:** 401 Unauthorized\n**Use Case:** Testing authentication requirement enforcement\n**Security Test:** Verify admin endpoints are properly protected"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for unauthorized access",
                      "",
                      "pm.test('Unauthorized access returns 401', function () {",
                      "    pm.expect(pm.response.code).to.equal(401);",
                      "});",
                      "",
                      "pm.test('Error response has proper structure', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('message');",
                      "});",
                      "",
                      "pm.test('No sensitive data in error response', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.not.have.property('googleSsoEnabled');",
                      "    pm.expect(responseJson).to.not.have.property('googleAutoProvision');",
                      "});",
                      "",
                      "console.log('‚úÖ Authentication requirement properly enforced');"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "üë• User Management",
      "description": "Complete user lifecycle management with roles and permissions",
      "item": [
        {
          "name": "CRUD Operations",
          "description": "Create, read, update, and delete user operations",
          "item": [
            {
              "name": "Get All Users",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text",
                    "description": "Tenant identifier for multi-tenant isolation"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/users",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "users"
                  ]
                },
                "description": "Retrieve all users in the current tenant. Requires 'read:user' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token with valid JWT\n- `x-tenant-id`: Tenant identifier\n\n**Required Permissions:** read:user\n\n**Response:**\n- Array of user objects with basic information\n- Each user includes id, email, firstName, lastName, createdAt, updatedAt\n\n**Use Cases:**\n- User management dashboard\n- User selection for role/permission assignment\n- Tenant user overview\n\n**Rate Limiting:** Standard API rate limits apply"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Get All Users",
                      "",
                      "pm.test('Status code is 200', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response is an array', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('array');",
                      "});",
                      "",
                      "pm.test('Users have required properties', function () {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.length > 0) {",
                      "        const user = responseJson[0];",
                      "        pm.expect(user).to.have.property('id');",
                      "        pm.expect(user).to.have.property('email');",
                      "        pm.expect(user).to.have.property('createdAt');",
                      "        pm.expect(user).to.have.property('updatedAt');",
                      "        ",
                      "        // Capture first user ID for subsequent tests",
                      "        if (!pm.collectionVariables.get('userId')) {",
                      "            pm.collectionVariables.set('userId', user.id);",
                      "            console.log('‚úÖ User ID captured:', user.id);",
                      "        }",
                      "    }",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});",
                      "",
                      "console.log('üìã Retrieved', pm.response.json().length, 'users');"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Get User by ID",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/users/{{userId}}",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "users",
                    "{{userId}}"
                  ]
                },
                "description": "Retrieve a specific user by their ID with detailed information including roles and permissions. Requires 'read:user' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token with valid JWT\n- `x-tenant-id`: Tenant identifier\n\n**Path Parameters:**\n- `id`: User ID (UUID format)\n\n**Required Permissions:** read:user\n\n**Response:**\n- User object with detailed information\n- Includes roles and permissions if available\n\n**Error Responses:**\n- 404: User not found\n- 403: Insufficient permissions\n- 401: Invalid or missing authentication\n\n**Use Cases:**\n- User profile viewing\n- User details for editing\n- Permission verification"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Get User by ID",
                      "",
                      "pm.test('Status code is 200 or 404', function () {",
                      "    pm.expect(pm.response.code).to.be.oneOf([200, 404]);",
                      "});",
                      "",
                      "if (pm.response.code === 200) {",
                      "    pm.test('User object has required properties', function () {",
                      "        const user = pm.response.json();",
                      "        pm.expect(user).to.have.property('id');",
                      "        pm.expect(user).to.have.property('email');",
                      "        pm.expect(user).to.have.property('createdAt');",
                      "        pm.expect(user).to.have.property('updatedAt');",
                      "        ",
                      "        // Verify the ID matches the requested ID",
                      "        const requestedId = pm.collectionVariables.get('userId');",
                      "        pm.expect(user.id).to.equal(requestedId);",
                      "    });",
                      "    ",
                      "    pm.test('User email is valid format', function () {",
                      "        const user = pm.response.json();",
                      "        pm.expect(user.email).to.match(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/);",
                      "    });",
                      "    ",
                      "    console.log('üë§ User details retrieved for:', pm.response.json().email);",
                      "} else if (pm.response.code === 404) {",
                      "    pm.test('404 response has error message', function () {",
                      "        const responseJson = pm.response.json();",
                      "        pm.expect(responseJson).to.have.property('message');",
                      "    });",
                      "    console.log('‚ùå User not found');",
                      "}",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(2000);",
                      "});"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Get User by ID",
                      "",
                      "const userId = pm.collectionVariables.get('userId');",
                      "if (!userId) {",
                      "    console.log('‚ö†Ô∏è Warning: userId not set. Run \"Get All Users\" first to capture a user ID.');",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Create User",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  },
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"email\": \"newuser@example.com\",\n  \"password\": \"SecurePass123!\",\n  \"firstName\": \"John\",\n  \"lastName\": \"Doe\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/users",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "users"
                  ]
                },
                "description": "Create a new user in the current tenant. Requires 'create:user' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token with valid JWT\n- `x-tenant-id`: Tenant identifier\n- `Content-Type`: application/json\n\n**Request Body:**\n- `email` (required): Valid email address\n- `password` (required): Minimum 8 characters\n- `firstName` (optional): User's first name\n- `lastName` (optional): User's last name\n\n**Required Permissions:** create:user\n\n**Response:**\n- Created user object (password excluded)\n- Includes generated user ID\n\n**Error Responses:**\n- 409: Email already exists\n- 400: Invalid request data\n- 403: Insufficient permissions\n\n**Use Cases:**\n- User registration by admin\n- Bulk user creation\n- Team member invitation"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Create User",
                      "",
                      "pm.test('Status code is 201', function () {",
                      "    pm.expect(pm.response.code).to.equal(201);",
                      "});",
                      "",
                      "pm.test('Created user has required properties', function () {",
                      "    const user = pm.response.json();",
                      "    pm.expect(user).to.have.property('id');",
                      "    pm.expect(user).to.have.property('email');",
                      "    pm.expect(user).to.have.property('createdAt');",
                      "    pm.expect(user).to.have.property('updatedAt');",
                      "    ",
                      "    // Password should not be returned",
                      "    pm.expect(user).to.not.have.property('password');",
                      "});",
                      "",
                      "pm.test('User email matches request', function () {",
                      "    const user = pm.response.json();",
                      "    const requestBody = JSON.parse(pm.request.body.raw);",
                      "    pm.expect(user.email).to.equal(requestBody.email);",
                      "});",
                      "",
                      "// Capture the new user ID for subsequent operations",
                      "pm.test('User ID captured successfully', function () {",
                      "    const user = pm.response.json();",
                      "    if (user.id) {",
                      "        pm.collectionVariables.set('userId', user.id);",
                      "        console.log('‚úÖ New user ID captured:', user.id);",
                      "        console.log('üë§ Created user:', user.email);",
                      "    }",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Create User",
                      "",
                      "// Generate unique email to avoid conflicts",
                      "const timestamp = Date.now();",
                      "const uniqueEmail = `testuser${timestamp}@example.com`;",
                      "",
                      "// Update the request body with unique email",
                      "const requestBody = JSON.parse(pm.request.body.raw);",
                      "requestBody.email = uniqueEmail;",
                      "pm.request.body.raw = JSON.stringify(requestBody, null, 2);",
                      "",
                      "console.log('üîÑ Generated unique email:', uniqueEmail);"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Update User",
              "request": {
                "method": "PUT",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  },
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"firstName\": \"Jane\",\n  \"lastName\": \"Smith\",\n  \"email\": \"updated@example.com\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/users/{{userId}}",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "users",
                    "{{userId}}"
                  ]
                },
                "description": "Update an existing user's information. Requires 'update:user' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token with valid JWT\n- `x-tenant-id`: Tenant identifier\n- `Content-Type`: application/json\n\n**Path Parameters:**\n- `id`: User ID to update\n\n**Request Body (all optional):**\n- `email`: New email address\n- `firstName`: Updated first name\n- `lastName`: Updated last name\n\n**Required Permissions:** update:user\n\n**Response:**\n- Updated user object\n- Includes updated timestamp\n\n**Error Responses:**\n- 404: User not found\n- 409: Email already exists (if changing email)\n- 400: Invalid request data\n- 403: Insufficient permissions\n\n**Use Cases:**\n- Profile updates\n- Administrative user management\n- Contact information changes"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Update User",
                      "",
                      "pm.test('Status code is 200 or 404', function () {",
                      "    pm.expect(pm.response.code).to.be.oneOf([200, 404]);",
                      "});",
                      "",
                      "if (pm.response.code === 200) {",
                      "    pm.test('Updated user has required properties', function () {",
                      "        const user = pm.response.json();",
                      "        pm.expect(user).to.have.property('id');",
                      "        pm.expect(user).to.have.property('email');",
                      "        pm.expect(user).to.have.property('updatedAt');",
                      "    });",
                      "    ",
                      "    pm.test('User data reflects updates', function () {",
                      "        const user = pm.response.json();",
                      "        const requestBody = JSON.parse(pm.request.body.raw);",
                      "        ",
                      "        if (requestBody.firstName) {",
                      "            pm.expect(user.firstName).to.equal(requestBody.firstName);",
                      "        }",
                      "        if (requestBody.lastName) {",
                      "            pm.expect(user.lastName).to.equal(requestBody.lastName);",
                      "        }",
                      "        if (requestBody.email) {",
                      "            pm.expect(user.email).to.equal(requestBody.email);",
                      "        }",
                      "    });",
                      "    ",
                      "    console.log('‚úÖ User updated successfully:', pm.response.json().email);",
                      "} else if (pm.response.code === 404) {",
                      "    console.log('‚ùå User not found for update');",
                      "}",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(2000);",
                      "});"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Update User",
                      "",
                      "const userId = pm.collectionVariables.get('userId');",
                      "if (!userId) {",
                      "    console.log('‚ö†Ô∏è Warning: userId not set. Create a user first or run \"Get All Users\".');",
                      "}",
                      "",
                      "// Generate unique email to avoid conflicts",
                      "const timestamp = Date.now();",
                      "const requestBody = JSON.parse(pm.request.body.raw);",
                      "if (requestBody.email) {",
                      "    requestBody.email = `updated${timestamp}@example.com`;",
                      "    pm.request.body.raw = JSON.stringify(requestBody, null, 2);",
                      "    console.log('üîÑ Generated unique email for update:', requestBody.email);",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Delete User",
              "request": {
                "method": "DELETE",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/users/{{userId}}",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "users",
                    "{{userId}}"
                  ]
                },
                "description": "Delete a user and all their role/permission assignments. Requires 'delete:user' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token with valid JWT\n- `x-tenant-id`: Tenant identifier\n\n**Path Parameters:**\n- `id`: User ID to delete\n\n**Required Permissions:** delete:user\n\n**Response:**\n- Success message confirming deletion\n\n**Error Responses:**\n- 404: User not found\n- 403: Insufficient permissions\n- 400: Cannot delete (e.g., last admin user)\n\n**Important Notes:**\n- This action is irreversible\n- All user's role and permission assignments are also deleted\n- User's created content may remain but will be orphaned\n\n**Use Cases:**\n- Employee offboarding\n- Account cleanup\n- Administrative user management"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Delete User",
                      "",
                      "pm.test('Status code is 200 or 404', function () {",
                      "    pm.expect(pm.response.code).to.be.oneOf([200, 404]);",
                      "});",
                      "",
                      "if (pm.response.code === 200) {",
                      "    pm.test('Deletion response has success message', function () {",
                      "        const responseJson = pm.response.json();",
                      "        pm.expect(responseJson).to.have.property('message');",
                      "    });",
                      "    ",
                      "    console.log('‚úÖ User deleted successfully');",
                      "    ",
                      "    // Clear the userId variable since user is deleted",
                      "    pm.collectionVariables.set('userId', '');",
                      "    console.log('üßπ Cleared userId variable');",
                      "} else if (pm.response.code === 404) {",
                      "    console.log('‚ùå User not found for deletion');",
                      "}",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(2000);",
                      "});"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Delete User",
                      "",
                      "const userId = pm.collectionVariables.get('userId');",
                      "if (!userId) {",
                      "    console.log('‚ö†Ô∏è Warning: userId not set. Create a user first or run \"Get All Users\".');",
                      "} else {",
                      "    console.log('üóëÔ∏è Preparing to delete user:', userId);",
                      "}"
                    ]
                  }
                }
              ]
            }
          ]
        },
        {
          "name": "Role Assignment",
          "description": "Assign and manage user roles",
          "item": [
            {
              "name": "Assign Roles to User",
              "request": {
                "method": "PUT",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  },
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"roleIds\": [\"{{roleId}}\"]\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/users/{{userId}}/roles",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "users",
                    "{{userId}}",
                    "roles"
                  ]
                },
                "description": "Replace user roles with the provided role IDs. This operation replaces all existing roles. Requires 'update:user' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token with valid JWT\n- `x-tenant-id`: Tenant identifier\n- `Content-Type`: application/json\n\n**Path Parameters:**\n- `id`: User ID to assign roles to\n\n**Request Body:**\n- `roleIds`: Array of role IDs to assign to the user\n\n**Required Permissions:** update:user\n\n**Response:**\n- Updated user object with new role assignments\n- Includes role details if expanded\n\n**Error Responses:**\n- 404: User or role not found\n- 403: Insufficient permissions\n- 400: Invalid role IDs\n\n**Important Notes:**\n- This replaces ALL existing roles\n- To add roles without replacing, use PATCH (if available)\n- Empty array removes all roles\n\n**Use Cases:**\n- Role management by administrators\n- User promotion/demotion\n- Bulk role assignment changes"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Assign Roles to User",
                      "",
                      "pm.test('Status code is 200 or 404', function () {",
                      "    pm.expect(pm.response.code).to.be.oneOf([200, 404]);",
                      "});",
                      "",
                      "if (pm.response.code === 200) {",
                      "    pm.test('Response contains user with roles', function () {",
                      "        const responseJson = pm.response.json();",
                      "        pm.expect(responseJson).to.have.property('id');",
                      "        ",
                      "        // Check if roles are included in response",
                      "        if (responseJson.roles) {",
                      "            pm.expect(responseJson.roles).to.be.an('array');",
                      "            console.log('üë• User now has', responseJson.roles.length, 'role(s)');",
                      "        }",
                      "    });",
                      "    ",
                      "    pm.test('Role assignment reflects request', function () {",
                      "        const requestBody = JSON.parse(pm.request.body.raw);",
                      "        const responseJson = pm.response.json();",
                      "        ",
                      "        if (responseJson.roles && requestBody.roleIds) {",
                      "            // Verify the number of roles matches (if roles are expanded)",
                      "            if (responseJson.roles.length > 0 && typeof responseJson.roles[0] === 'object') {",
                      "                pm.expect(responseJson.roles.length).to.equal(requestBody.roleIds.length);",
                      "            }",
                      "        }",
                      "    });",
                      "    ",
                      "    console.log('‚úÖ Roles assigned successfully to user');",
                      "} else if (pm.response.code === 404) {",
                      "    pm.test('404 response has error message', function () {",
                      "        const responseJson = pm.response.json();",
                      "        pm.expect(responseJson).to.have.property('message');",
                      "    });",
                      "    console.log('‚ùå User or role not found');",
                      "}",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Assign Roles to User",
                      "",
                      "const userId = pm.collectionVariables.get('userId');",
                      "const roleId = pm.collectionVariables.get('roleId');",
                      "",
                      "if (!userId) {",
                      "    console.log('‚ö†Ô∏è Warning: userId not set. Create a user first or run \"Get All Users\".');",
                      "}",
                      "",
                      "if (!roleId) {",
                      "    console.log('‚ö†Ô∏è Warning: roleId not set. Create a role first or set roleId manually.');",
                      "    console.log('üí° Tip: You can set a roleId manually in the environment variables.');",
                      "} else {",
                      "    console.log('üë• Assigning role', roleId, 'to user', userId);",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Assign Multiple Roles Example",
              "request": {
                "method": "PUT",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  },
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"roleIds\": [\n    \"role-admin-id\",\n    \"role-user-id\",\n    \"role-viewer-id\"\n  ]\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/users/{{userId}}/roles",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "users",
                    "{{userId}}",
                    "roles"
                  ]
                },
                "description": "Example of assigning multiple roles to a user simultaneously. This demonstrates how to assign multiple roles in a single request.\n\n**Use Case:** Assigning multiple roles to a user who needs various permissions\n**Example Scenario:** A user who needs both admin and viewer roles\n\n**Note:** Replace the role IDs in the request body with actual role IDs from your system."
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for multiple role assignment",
                      "",
                      "pm.test('Multiple roles assigned successfully', function () {",
                      "    pm.expect(pm.response.code).to.be.oneOf([200, 404]);",
                      "});",
                      "",
                      "if (pm.response.code === 200) {",
                      "    const requestBody = JSON.parse(pm.request.body.raw);",
                      "    console.log('‚úÖ Assigned', requestBody.roleIds.length, 'roles to user');",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Remove All Roles Example",
              "request": {
                "method": "PUT",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  },
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"roleIds\": []\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/users/{{userId}}/roles",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "users",
                    "{{userId}}",
                    "roles"
                  ]
                },
                "description": "Example of removing all roles from a user by providing an empty roleIds array.\n\n**Use Case:** Removing all roles from a user (e.g., during role restructuring)\n**Important:** This will remove ALL roles from the user, potentially affecting their access permissions"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for removing all roles",
                      "",
                      "pm.test('All roles removed successfully', function () {",
                      "    pm.expect(pm.response.code).to.be.oneOf([200, 404]);",
                      "});",
                      "",
                      "if (pm.response.code === 200) {",
                      "    console.log('‚úÖ All roles removed from user');",
                      "}"
                    ]
                  }
                }
              ]
            }
          ]
        },
        {
          "name": "Permission Management",
          "description": "Manage user permissions and view effective permissions",
          "item": [
            {
              "name": "Assign Permissions to User",
              "request": {
                "method": "PUT",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  },
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"permissionIds\": [\"{{permissionId}}\"]\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/users/{{userId}}/permissions",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "users",
                    "{{userId}}",
                    "permissions"
                  ]
                },
                "description": "Grant user-specific permissions directly to a user. These permissions are in addition to role-based permissions. Requires 'update:user' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token with valid JWT\n- `x-tenant-id`: Tenant identifier\n- `Content-Type`: application/json\n\n**Path Parameters:**\n- `id`: User ID to assign permissions to\n\n**Request Body:**\n- `permissionIds`: Array of permission IDs to assign directly to the user\n\n**Required Permissions:** update:user\n\n**Response:**\n- Updated user object with new permission assignments\n- May include permission details if expanded\n\n**Error Responses:**\n- 404: User or permission not found\n- 403: Insufficient permissions\n- 400: Invalid permission IDs\n\n**Important Notes:**\n- These are user-specific permissions (not role-based)\n- User-specific permissions are additive to role permissions\n- Use sparingly - prefer role-based permissions for maintainability\n\n**Use Cases:**\n- Temporary permission grants\n- Special access requirements\n- Fine-grained permission control"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Assign Permissions to User",
                      "",
                      "pm.test('Status code is 200 or 404', function () {",
                      "    pm.expect(pm.response.code).to.be.oneOf([200, 404]);",
                      "});",
                      "",
                      "if (pm.response.code === 200) {",
                      "    pm.test('Response contains user with permissions', function () {",
                      "        const responseJson = pm.response.json();",
                      "        pm.expect(responseJson).to.have.property('id');",
                      "        ",
                      "        // Check if permissions are included in response",
                      "        if (responseJson.permissions) {",
                      "            pm.expect(responseJson.permissions).to.be.an('array');",
                      "            console.log('üîê User now has', responseJson.permissions.length, 'direct permission(s)');",
                      "        }",
                      "    });",
                      "    ",
                      "    pm.test('Permission assignment reflects request', function () {",
                      "        const requestBody = JSON.parse(pm.request.body.raw);",
                      "        const responseJson = pm.response.json();",
                      "        ",
                      "        if (responseJson.permissions && requestBody.permissionIds) {",
                      "            // Verify permissions were assigned (if permissions are expanded)",
                      "            if (responseJson.permissions.length > 0 && typeof responseJson.permissions[0] === 'object') {",
                      "                pm.expect(responseJson.permissions.length).to.equal(requestBody.permissionIds.length);",
                      "            }",
                      "        }",
                      "    });",
                      "    ",
                      "    console.log('‚úÖ Permissions assigned successfully to user');",
                      "} else if (pm.response.code === 404) {",
                      "    pm.test('404 response has error message', function () {",
                      "        const responseJson = pm.response.json();",
                      "        pm.expect(responseJson).to.have.property('message');",
                      "    });",
                      "    console.log('‚ùå User or permission not found');",
                      "}",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Assign Permissions to User",
                      "",
                      "const userId = pm.collectionVariables.get('userId');",
                      "const permissionId = pm.collectionVariables.get('permissionId');",
                      "",
                      "if (!userId) {",
                      "    console.log('‚ö†Ô∏è Warning: userId not set. Create a user first or run \"Get All Users\".');",
                      "}",
                      "",
                      "if (!permissionId) {",
                      "    console.log('‚ö†Ô∏è Warning: permissionId not set. Create a permission first or set permissionId manually.');",
                      "    console.log('üí° Tip: You can set a permissionId manually in the environment variables.');",
                      "} else {",
                      "    console.log('üîê Assigning permission', permissionId, 'to user', userId);",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Get User Effective Permissions",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/users/{{userId}}/permissions",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "users",
                    "{{userId}}",
                    "permissions"
                  ]
                },
                "description": "Get all effective permissions for a user, including both role-based and user-specific permissions. Requires 'read:user' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token with valid JWT\n- `x-tenant-id`: Tenant identifier\n\n**Path Parameters:**\n- `id`: User ID to get permissions for\n\n**Required Permissions:** read:user\n\n**Response:**\n- Array of all effective permissions for the user\n- Includes permissions from roles and direct user assignments\n- May include permission source information (role vs direct)\n\n**Error Responses:**\n- 404: User not found\n- 403: Insufficient permissions\n\n**Response Structure:**\n- Each permission includes: id, name, description, source\n- Source indicates if permission comes from role or direct assignment\n\n**Use Cases:**\n- Permission auditing\n- Access control verification\n- Debugging permission issues\n- Security compliance checks"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Get User Effective Permissions",
                      "",
                      "pm.test('Status code is 200 or 404', function () {",
                      "    pm.expect(pm.response.code).to.be.oneOf([200, 404]);",
                      "});",
                      "",
                      "if (pm.response.code === 200) {",
                      "    pm.test('Response is an array of permissions', function () {",
                      "        const permissions = pm.response.json();",
                      "        pm.expect(permissions).to.be.an('array');",
                      "    });",
                      "    ",
                      "    pm.test('Permissions have required properties', function () {",
                      "        const permissions = pm.response.json();",
                      "        if (permissions.length > 0) {",
                      "            const permission = permissions[0];",
                      "            pm.expect(permission).to.have.property('id');",
                      "            pm.expect(permission).to.have.property('name');",
                      "            ",
                      "            // Log permission details",
                      "            console.log('üîê First permission:', permission.name);",
                      "            if (permission.source) {",
                      "                console.log('üìç Source:', permission.source);",
                      "            }",
                      "        }",
                      "    });",
                      "    ",
                      "    pm.test('Permission analysis', function () {",
                      "        const permissions = pm.response.json();",
                      "        const totalPermissions = permissions.length;",
                      "        ",
                      "        // Count permissions by source if available",
                      "        const rolePermissions = permissions.filter(p => p.source === 'role').length;",
                      "        const directPermissions = permissions.filter(p => p.source === 'direct').length;",
                      "        ",
                      "        console.log('üìä Permission Summary:');",
                      "        console.log('  Total effective permissions:', totalPermissions);",
                      "        if (rolePermissions > 0) console.log('  From roles:', rolePermissions);",
                      "        if (directPermissions > 0) console.log('  Direct assignments:', directPermissions);",
                      "        ",
                      "        // List all permission names",
                      "        const permissionNames = permissions.map(p => p.name).join(', ');",
                      "        console.log('  Permissions:', permissionNames || 'None');",
                      "    });",
                      "    ",
                      "    console.log('‚úÖ Effective permissions retrieved successfully');",
                      "} else if (pm.response.code === 404) {",
                      "    console.log('‚ùå User not found');",
                      "}",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(2000);",
                      "});"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Get User Effective Permissions",
                      "",
                      "const userId = pm.collectionVariables.get('userId');",
                      "if (!userId) {",
                      "    console.log('‚ö†Ô∏è Warning: userId not set. Create a user first or run \"Get All Users\".');",
                      "} else {",
                      "    console.log('üîç Getting effective permissions for user:', userId);",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Assign Multiple Permissions Example",
              "request": {
                "method": "PUT",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  },
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"permissionIds\": [\n    \"read:user\",\n    \"update:user\",\n    \"read:project\"\n  ]\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/users/{{userId}}/permissions",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "users",
                    "{{userId}}",
                    "permissions"
                  ]
                },
                "description": "Example of assigning multiple permissions directly to a user. This demonstrates granting specific permissions that may not be covered by the user's roles.\n\n**Use Case:** Granting specific permissions for temporary access or special requirements\n**Example Scenario:** A user who needs read access to users and projects but not full admin rights\n\n**Note:** Replace the permission IDs with actual permission IDs from your system."
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for multiple permission assignment",
                      "",
                      "pm.test('Multiple permissions assigned successfully', function () {",
                      "    pm.expect(pm.response.code).to.be.oneOf([200, 404]);",
                      "});",
                      "",
                      "if (pm.response.code === 200) {",
                      "    const requestBody = JSON.parse(pm.request.body.raw);",
                      "    console.log('‚úÖ Assigned', requestBody.permissionIds.length, 'permissions to user');",
                      "    console.log('üîê Permissions:', requestBody.permissionIds.join(', '));",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Remove All User Permissions Example",
              "request": {
                "method": "PUT",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  },
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"permissionIds\": []\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/users/{{userId}}/permissions",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "users",
                    "{{userId}}",
                    "permissions"
                  ]
                },
                "description": "Example of removing all direct permissions from a user by providing an empty permissionIds array. The user will still retain permissions from their assigned roles.\n\n**Use Case:** Cleaning up direct permission assignments while keeping role-based permissions\n**Important:** This only removes direct user permissions, not role-based permissions"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for removing all direct permissions",
                      "",
                      "pm.test('All direct permissions removed successfully', function () {",
                      "    pm.expect(pm.response.code).to.be.oneOf([200, 404]);",
                      "});",
                      "",
                      "if (pm.response.code === 200) {",
                      "    console.log('‚úÖ All direct permissions removed from user');",
                      "    console.log('‚ÑπÔ∏è User still retains role-based permissions');",
                      "}"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "üõ°Ô∏è Role & Permission System",
      "description": "Role-based access control system management",
      "item": [
        {
          "name": "Role Management",
          "description": "Create and manage roles with permission assignments",
          "item": [
            {
              "name": "Get All Roles",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text",
                    "description": "Tenant identifier for role isolation"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/roles",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "roles"
                  ]
                },
                "description": "Retrieve all roles in the current tenant with their associated permissions. Requires 'read:role' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n\n**Required Permission:** read:role\n\n**Response:**\n- Array of role objects with permissions\n- Each role includes: id, name, description, tenantId, createdAt, updatedAt, permissions\n\n**Use Cases:**\n- List available roles for assignment\n- Role management interface\n- Permission auditing"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Get All Roles",
                      "",
                      "pm.test('Status code is 200', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response is an array', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('array');",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(2000);",
                      "});",
                      "",
                      "// Capture first role ID if available",
                      "if (pm.response.code === 200) {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.length > 0) {",
                      "        pm.collectionVariables.set('roleId', responseJson[0].id);",
                      "        console.log('‚úÖ Role ID captured:', responseJson[0].id);",
                      "        console.log('üìã Available roles:', responseJson.map(r => r.name).join(', '));",
                      "    } else {",
                      "        console.log('‚ÑπÔ∏è No roles found in tenant');",
                      "    }",
                      "}",
                      "",
                      "// Validate role structure if roles exist",
                      "if (pm.response.code === 200) {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.length > 0) {",
                      "        pm.test('Role objects have required properties', function () {",
                      "            const role = responseJson[0];",
                      "            pm.expect(role).to.have.property('id');",
                      "            pm.expect(role).to.have.property('name');",
                      "            pm.expect(role).to.have.property('tenantId');",
                      "            pm.expect(role).to.have.property('createdAt');",
                      "            pm.expect(role).to.have.property('updatedAt');",
                      "        });",
                      "    }",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Get Role by ID",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/roles/{{roleId}}",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "roles",
                    "{{roleId}}"
                  ]
                },
                "description": "Retrieve a specific role by ID with its permissions. Requires 'read:role' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n\n**Path Parameters:**\n- `id`: Role ID\n\n**Required Permission:** read:role\n\n**Response:**\n- Role object with full details and permissions\n\n**Use Cases:**\n- View role details\n- Edit role form population\n- Permission analysis"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Get Role by ID",
                      "",
                      "pm.test('Status code is 200', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response is a role object', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('object');",
                      "    pm.expect(responseJson).to.have.property('id');",
                      "    pm.expect(responseJson).to.have.property('name');",
                      "});",
                      "",
                      "pm.test('Role ID matches requested ID', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const requestedId = pm.collectionVariables.get('roleId');",
                      "    pm.expect(responseJson.id).to.equal(requestedId);",
                      "});",
                      "",
                      "pm.test('Role has permissions array', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('permissions');",
                      "    pm.expect(responseJson.permissions).to.be.an('array');",
                      "});",
                      "",
                      "// Log role details",
                      "if (pm.response.code === 200) {",
                      "    const role = pm.response.json();",
                      "    console.log('üé≠ Role Details:');",
                      "    console.log('  Name:', role.name);",
                      "    console.log('  Description:', role.description || 'No description');",
                      "    console.log('  Permissions:', role.permissions?.length || 0);",
                      "    if (role.permissions?.length > 0) {",
                      "        console.log('  Permission names:', role.permissions.map(p => p.name).join(', '));",
                      "    }",
                      "}"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Get Role by ID",
                      "",
                      "const roleId = pm.collectionVariables.get('roleId');",
                      "if (!roleId) {",
                      "    console.log('‚ö†Ô∏è Warning: roleId not set. Run \"Get All Roles\" first to capture a role ID.');",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Create Role",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"name\": \"Content Manager\",\n  \"description\": \"Can manage all content within the tenant\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/roles",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "roles"
                  ]
                },
                "description": "Create a new role in the current tenant. Requires 'create:role' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n- `Content-Type`: application/json\n\n**Request Body:**\n- `name`: Role name (required, string)\n- `description`: Role description (optional, string)\n\n**Required Permission:** create:role\n\n**Response:**\n- Created role object with generated ID\n\n**Example Role Names:**\n- Admin, Editor, Viewer, Content Manager, Project Manager, Support Agent\n\n**Use Cases:**\n- Create custom roles for organization\n- Set up role-based access control\n- Define permission groups"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Create Role",
                      "",
                      "pm.test('Status code is 201', function () {",
                      "    pm.expect(pm.response.code).to.equal(201);",
                      "});",
                      "",
                      "pm.test('Response contains created role', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('object');",
                      "    pm.expect(responseJson).to.have.property('id');",
                      "    pm.expect(responseJson).to.have.property('name');",
                      "    pm.expect(responseJson).to.have.property('tenantId');",
                      "});",
                      "",
                      "pm.test('Role name matches request', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const requestBody = JSON.parse(pm.request.body.raw);",
                      "    pm.expect(responseJson.name).to.equal(requestBody.name);",
                      "});",
                      "",
                      "// Capture created role ID",
                      "if (pm.response.code === 201) {",
                      "    const responseJson = pm.response.json();",
                      "    pm.collectionVariables.set('roleId', responseJson.id);",
                      "    console.log('‚úÖ Role created successfully');",
                      "    console.log('üÜî Role ID captured:', responseJson.id);",
                      "    console.log('üé≠ Role name:', responseJson.name);",
                      "}",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Update Role",
              "request": {
                "method": "PUT",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"name\": \"Senior Content Manager\",\n  \"description\": \"Senior role with enhanced content management capabilities\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/roles/{{roleId}}",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "roles",
                    "{{roleId}}"
                  ]
                },
                "description": "Update an existing role's name and description. Requires 'update:role' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n- `Content-Type`: application/json\n\n**Path Parameters:**\n- `id`: Role ID to update\n\n**Request Body:**\n- `name`: New role name (required, string)\n- `description`: New role description (optional, string)\n\n**Required Permission:** update:role\n\n**Response:**\n- Updated role object\n\n**Use Cases:**\n- Rename roles\n- Update role descriptions\n- Role maintenance"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Update Role",
                      "",
                      "pm.test('Status code is 200', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response contains updated role', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('object');",
                      "    pm.expect(responseJson).to.have.property('id');",
                      "    pm.expect(responseJson).to.have.property('name');",
                      "});",
                      "",
                      "pm.test('Role name was updated', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const requestBody = JSON.parse(pm.request.body.raw);",
                      "    pm.expect(responseJson.name).to.equal(requestBody.name);",
                      "});",
                      "",
                      "pm.test('Updated timestamp is recent', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const updatedAt = new Date(responseJson.updatedAt);",
                      "    const now = new Date();",
                      "    const timeDiff = now - updatedAt;",
                      "    pm.expect(timeDiff).to.be.below(60000); // Within last minute",
                      "});",
                      "",
                      "// Log update confirmation",
                      "if (pm.response.code === 200) {",
                      "    const role = pm.response.json();",
                      "    console.log('‚úÖ Role updated successfully');",
                      "    console.log('üé≠ New name:', role.name);",
                      "    console.log('üìù Description:', role.description || 'No description');",
                      "}"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Update Role",
                      "",
                      "const roleId = pm.collectionVariables.get('roleId');",
                      "if (!roleId) {",
                      "    console.log('‚ö†Ô∏è Warning: roleId not set. Create a role first or run \"Get All Roles\" to capture an ID.');",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Assign Permissions to Role",
              "request": {
                "method": "PUT",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"permissionIds\": [\n    \"{{permissionId}}\"\n  ]\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/roles/{{roleId}}/permissions",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "roles",
                    "{{roleId}}",
                    "permissions"
                  ]
                },
                "description": "Replace all permissions for a role with the provided list. This operation completely replaces the role's permissions. Requires 'update:role' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n- `Content-Type`: application/json\n\n**Path Parameters:**\n- `id`: Role ID to update permissions for\n\n**Request Body:**\n- `permissionIds`: Array of permission IDs to assign (replaces all existing)\n\n**Required Permission:** update:role\n\n**Response:**\n- Updated role object with new permissions\n\n**Important:** This replaces ALL permissions. To add permissions, include existing ones in the array.\n\n**Use Cases:**\n- Configure role permissions\n- Update access control\n- Permission management"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Assign Permissions to Role",
                      "",
                      "pm.test('Status code is 200', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response contains role with permissions', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('object');",
                      "    pm.expect(responseJson).to.have.property('id');",
                      "    pm.expect(responseJson).to.have.property('permissions');",
                      "});",
                      "",
                      "pm.test('Permissions were assigned correctly', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const requestBody = JSON.parse(pm.request.body.raw);",
                      "    const assignedPermissionIds = responseJson.permissions.map(p => p.id);",
                      "    ",
                      "    requestBody.permissionIds.forEach(permId => {",
                      "        pm.expect(assignedPermissionIds).to.include(permId);",
                      "    });",
                      "});",
                      "",
                      "// Log permission assignment results",
                      "if (pm.response.code === 200) {",
                      "    const role = pm.response.json();",
                      "    const requestBody = JSON.parse(pm.request.body.raw);",
                      "    console.log('‚úÖ Permissions assigned successfully');",
                      "    console.log('üé≠ Role:', role.name);",
                      "    console.log('üìã Assigned permissions:', role.permissions.length);",
                      "    console.log('üîë Permission names:', role.permissions.map(p => p.name).join(', '));",
                      "}"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Assign Permissions to Role",
                      "",
                      "const roleId = pm.collectionVariables.get('roleId');",
                      "const permissionId = pm.collectionVariables.get('permissionId');",
                      "",
                      "if (!roleId) {",
                      "    console.log('‚ö†Ô∏è Warning: roleId not set. Create a role first.');",
                      "}",
                      "",
                      "if (!permissionId) {",
                      "    console.log('‚ö†Ô∏è Warning: permissionId not set. Create a permission first or run \"Get All Permissions\".');",
                      "    console.log('üí° Tip: You can manually set permissionId or use multiple permission IDs in the request body.');",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Delete Role",
              "request": {
                "method": "DELETE",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/roles/{{roleId}}",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "roles",
                    "{{roleId}}"
                  ]
                },
                "description": "Delete a role and remove it from all users. This operation is irreversible. Requires 'delete:role' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n\n**Path Parameters:**\n- `id`: Role ID to delete\n\n**Required Permission:** delete:role\n\n**Response:**\n- Confirmation message\n\n**Important:** This removes the role from all users who have it assigned.\n\n**Use Cases:**\n- Remove obsolete roles\n- Clean up role structure\n- Role lifecycle management"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Delete Role",
                      "",
                      "pm.test('Status code is 200', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response contains confirmation message', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('object');",
                      "    // Response structure may vary, check for common success indicators",
                      "    const hasMessage = responseJson.message || responseJson.success || responseJson.deleted;",
                      "    pm.expect(hasMessage).to.exist;",
                      "});",
                      "",
                      "// Clear the deleted role ID",
                      "if (pm.response.code === 200) {",
                      "    console.log('‚úÖ Role deleted successfully');",
                      "    console.log('üßπ Clearing roleId variable');",
                      "    pm.collectionVariables.set('roleId', '');",
                      "}",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Delete Role",
                      "",
                      "const roleId = pm.collectionVariables.get('roleId');",
                      "if (!roleId) {",
                      "    console.log('‚ö†Ô∏è Warning: roleId not set. Create a role first or run \"Get All Roles\" to capture an ID.');",
                      "} else {",
                      "    console.log('üóëÔ∏è About to delete role ID:', roleId);",
                      "    console.log('‚ö†Ô∏è This action is irreversible and will remove the role from all users.');",
                      "}"
                    ]
                  }
                }
              ]
            }
          ]
        },
        {
          "name": "Permission Management",
          "description": "Create and manage individual permissions",
          "item": [
            {
              "name": "Get All Permissions",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text",
                    "description": "Tenant identifier for permission isolation"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/permissions",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "permissions"
                  ]
                },
                "description": "Retrieve all permissions in the current tenant. Requires 'read:permission' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n\n**Required Permission:** read:permission\n\n**Response:**\n- Array of permission objects\n- Each permission includes: id, name, description, tenantId, createdAt, updatedAt\n\n**Permission Format:**\n- Permissions follow the format: action:subject\n- Examples: read:user, create:project, delete:role, manage:notifications\n\n**Use Cases:**\n- List available permissions for role assignment\n- Permission management interface\n- Access control auditing"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Get All Permissions",
                      "",
                      "pm.test('Status code is 200', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response is an array', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('array');",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(2000);",
                      "});",
                      "",
                      "// Capture first permission ID if available",
                      "if (pm.response.code === 200) {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.length > 0) {",
                      "        pm.collectionVariables.set('permissionId', responseJson[0].id);",
                      "        console.log('‚úÖ Permission ID captured:', responseJson[0].id);",
                      "        console.log('üîë Available permissions:', responseJson.map(p => p.name).join(', '));",
                      "    } else {",
                      "        console.log('‚ÑπÔ∏è No permissions found in tenant');",
                      "    }",
                      "}",
                      "",
                      "// Validate permission structure if permissions exist",
                      "if (pm.response.code === 200) {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.length > 0) {",
                      "        pm.test('Permission objects have required properties', function () {",
                      "            const permission = responseJson[0];",
                      "            pm.expect(permission).to.have.property('id');",
                      "            pm.expect(permission).to.have.property('name');",
                      "            pm.expect(permission).to.have.property('tenantId');",
                      "            pm.expect(permission).to.have.property('createdAt');",
                      "            pm.expect(permission).to.have.property('updatedAt');",
                      "        });",
                      "        ",
                      "        pm.test('Permission names follow action:subject format', function () {",
                      "            const permissions = responseJson;",
                      "            permissions.forEach(permission => {",
                      "                // Check if permission name contains a colon (action:subject format)",
                      "                pm.expect(permission.name).to.match(/^[a-zA-Z_]+:[a-zA-Z_]+$/);",
                      "            });",
                      "        });",
                      "    }",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Create Permission",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"action\": \"manage\",\n  \"subject\": \"reports\",\n  \"description\": \"Can create, read, update, and delete reports\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/permissions",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "permissions"
                  ]
                },
                "description": "Create a new permission in the current tenant. Permissions follow the action:subject format. Requires 'create:permission' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n- `Content-Type`: application/json\n\n**Request Body:**\n- `action`: Permission action (required, string) - e.g., read, create, update, delete, manage\n- `subject`: Permission subject/resource (required, string) - e.g., user, project, role, notification\n- `description`: Permission description (optional, string)\n\n**Required Permission:** create:permission\n\n**Response:**\n- Created permission object with generated ID\n\n**Permission Examples:**\n- read:user, create:project, update:role, delete:notification\n- manage:reports (combines multiple actions)\n- admin:tenant (administrative access)\n\n**Use Cases:**\n- Define custom permissions for specific resources\n- Create fine-grained access control\n- Set up permission-based authorization"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Create Permission",
                      "",
                      "pm.test('Status code is 201', function () {",
                      "    pm.expect(pm.response.code).to.equal(201);",
                      "});",
                      "",
                      "pm.test('Response contains created permission', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('object');",
                      "    pm.expect(responseJson).to.have.property('id');",
                      "    pm.expect(responseJson).to.have.property('name');",
                      "    pm.expect(responseJson).to.have.property('tenantId');",
                      "});",
                      "",
                      "pm.test('Permission name follows action:subject format', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const requestBody = JSON.parse(pm.request.body.raw);",
                      "    const expectedName = `${requestBody.action}:${requestBody.subject}`;",
                      "    pm.expect(responseJson.name).to.equal(expectedName);",
                      "});",
                      "",
                      "pm.test('Permission has correct format', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson.name).to.match(/^[a-zA-Z_]+:[a-zA-Z_]+$/);",
                      "});",
                      "",
                      "// Capture created permission ID",
                      "if (pm.response.code === 201) {",
                      "    const responseJson = pm.response.json();",
                      "    pm.collectionVariables.set('permissionId', responseJson.id);",
                      "    console.log('‚úÖ Permission created successfully');",
                      "    console.log('üÜî Permission ID captured:', responseJson.id);",
                      "    console.log('üîë Permission name:', responseJson.name);",
                      "    console.log('üìù Description:', responseJson.description || 'No description');",
                      "}",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Create Permission - Read User Example",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"action\": \"read\",\n  \"subject\": \"user\",\n  \"description\": \"Can view user information and profiles\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/permissions",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "permissions"
                  ]
                },
                "description": "Example of creating a basic read permission for users. This demonstrates the standard permission format and is commonly used in role-based access control.\n\n**Permission Created:** read:user\n**Use Case:** Allow users to view other users' information\n**Common Assignment:** Assigned to most user roles for basic functionality"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Create Permission - Read User Example",
                      "",
                      "pm.test('Status code is 201', function () {",
                      "    pm.expect(pm.response.code).to.equal(201);",
                      "});",
                      "",
                      "pm.test('Permission name is read:user', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson.name).to.equal('read:user');",
                      "});",
                      "",
                      "// Log creation of standard permission",
                      "if (pm.response.code === 201) {",
                      "    console.log('‚úÖ Standard read:user permission created');",
                      "    console.log('üîë This is a commonly used permission for basic user access');",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Create Permission - Invalid Format Example",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"action\": \"\",\n  \"subject\": \"user\",\n  \"description\": \"Invalid permission with empty action\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/permissions",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "permissions"
                  ]
                },
                "description": "Example of invalid permission creation with empty action field. This demonstrates validation error handling.\n\n**Expected Response:** 400 Bad Request\n**Use Case:** Testing input validation and error handling"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Create Permission - Invalid Format Example",
                      "",
                      "pm.test('Status code is 400 for invalid input', function () {",
                      "    pm.expect(pm.response.code).to.equal(400);",
                      "});",
                      "",
                      "pm.test('Error response has proper structure', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('message');",
                      "});",
                      "",
                      "pm.test('Error message mentions validation', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const message = responseJson.message.toLowerCase();",
                      "    const hasValidationError = message.includes('validation') || ",
                      "                               message.includes('required') || ",
                      "                               message.includes('empty') ||",
                      "                               message.includes('action');",
                      "    pm.expect(hasValidationError).to.be.true;",
                      "});",
                      "",
                      "console.log('‚úÖ Validation error properly handled for empty action field');"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Delete Permission",
              "request": {
                "method": "DELETE",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/permissions/{{permissionId}}",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "permissions",
                    "{{permissionId}}"
                  ]
                },
                "description": "Delete a permission and remove it from all roles and users. This operation is irreversible. Requires 'delete:permission' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n\n**Path Parameters:**\n- `id`: Permission ID to delete\n\n**Required Permission:** delete:permission\n\n**Response:**\n- Confirmation message with deleted permission ID\n\n**Important:** This removes the permission from all roles and users who have it assigned.\n\n**Use Cases:**\n- Remove obsolete permissions\n- Clean up permission structure\n- Permission lifecycle management\n- Security cleanup"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Delete Permission",
                      "",
                      "pm.test('Status code is 200', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response contains confirmation message', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('object');",
                      "    // Check for common success indicators",
                      "    const hasConfirmation = responseJson.message || ",
                      "                           responseJson.success || ",
                      "                           responseJson.deletedPermissionId;",
                      "    pm.expect(hasConfirmation).to.exist;",
                      "});",
                      "",
                      "pm.test('Deleted permission ID is included in response', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const requestedId = pm.collectionVariables.get('permissionId');",
                      "    ",
                      "    // Check if the response includes the deleted permission ID",
                      "    const hasDeletedId = responseJson.deletedPermissionId === requestedId ||",
                      "                         responseJson.id === requestedId ||",
                      "                         (responseJson.message && responseJson.message.includes(requestedId));",
                      "    pm.expect(hasDeletedId).to.be.true;",
                      "});",
                      "",
                      "// Clear the deleted permission ID",
                      "if (pm.response.code === 200) {",
                      "    console.log('‚úÖ Permission deleted successfully');",
                      "    console.log('üßπ Clearing permissionId variable');",
                      "    pm.collectionVariables.set('permissionId', '');",
                      "}",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Delete Permission",
                      "",
                      "const permissionId = pm.collectionVariables.get('permissionId');",
                      "if (!permissionId) {",
                      "    console.log('‚ö†Ô∏è Warning: permissionId not set. Create a permission first or run \"Get All Permissions\" to capture an ID.');",
                      "} else {",
                      "    console.log('üóëÔ∏è About to delete permission ID:', permissionId);",
                      "    console.log('‚ö†Ô∏è This action is irreversible and will remove the permission from all roles and users.');",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Permission Validation Suite",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"action\": \"validate\",\n  \"subject\": \"permissions\",\n  \"description\": \"Test permission for validation suite\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/permissions",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "permissions"
                  ]
                },
                "description": "Comprehensive permission validation suite that tests multiple aspects of permission creation including format validation, tenant isolation, and security checks.\n\n**Validation Coverage:**\n- Permission name format validation\n- Tenant isolation verification\n- Duplicate permission handling\n- Response structure validation\n- Security header checks\n\n**Use Case:** Complete permission system validation and security testing"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Comprehensive Permission Validation Suite",
                      "",
                      "// Basic response validation",
                      "pm.test('Permission creation response is valid', function () {",
                      "    pm.expect(pm.response.code).to.be.oneOf([201, 409]); // Created or conflict",
                      "});",
                      "",
                      "// Format validation for successful creation",
                      "if (pm.response.code === 201) {",
                      "    pm.test('Permission format validation', function () {",
                      "        const responseJson = pm.response.json();",
                      "        const requestBody = JSON.parse(pm.request.body.raw);",
                      "        ",
                      "        // Validate permission name format",
                      "        const expectedName = `${requestBody.action}:${requestBody.subject}`;",
                      "        pm.expect(responseJson.name).to.equal(expectedName);",
                      "        ",
                      "        // Validate action:subject pattern",
                      "        pm.expect(responseJson.name).to.match(/^[a-zA-Z_]+:[a-zA-Z_]+$/);",
                      "        ",
                      "        console.log('‚úÖ Permission format validation passed');",
                      "        console.log('üîë Permission name:', responseJson.name);",
                      "    });",
                      "    ",
                      "    pm.test('Tenant isolation validation', function () {",
                      "        const responseJson = pm.response.json();",
                      "        const currentTenantId = pm.collectionVariables.get('tenantId');",
                      "        ",
                      "        // Verify permission belongs to current tenant",
                      "        pm.expect(responseJson.tenantId).to.equal(currentTenantId);",
                      "        ",
                      "        console.log('‚úÖ Tenant isolation validated');",
                      "        console.log('üè¢ Tenant ID:', responseJson.tenantId);",
                      "    });",
                      "    ",
                      "    pm.test('Permission metadata validation', function () {",
                      "        const responseJson = pm.response.json();",
                      "        ",
                      "        // Check required fields",
                      "        pm.expect(responseJson).to.have.property('id');",
                      "        pm.expect(responseJson).to.have.property('name');",
                      "        pm.expect(responseJson).to.have.property('tenantId');",
                      "        pm.expect(responseJson).to.have.property('createdAt');",
                      "        pm.expect(responseJson).to.have.property('updatedAt');",
                      "        ",
                      "        // Validate timestamps",
                      "        const createdAt = new Date(responseJson.createdAt);",
                      "        const updatedAt = new Date(responseJson.updatedAt);",
                      "        pm.expect(createdAt.getTime()).to.be.a('number');",
                      "        pm.expect(updatedAt.getTime()).to.be.a('number');",
                      "        ",
                      "        console.log('‚úÖ Permission metadata validation passed');",
                      "    });",
                      "    ",
                      "    // Capture permission for cleanup",
                      "    const responseJson = pm.response.json();",
                      "    pm.collectionVariables.set('permissionId', responseJson.id);",
                      "    console.log('üÜî Permission ID captured for validation suite:', responseJson.id);",
                      "}",
                      "",
                      "// Conflict handling validation",
                      "if (pm.response.code === 409) {",
                      "    pm.test('Duplicate permission handling', function () {",
                      "        const responseJson = pm.response.json();",
                      "        pm.expect(responseJson).to.have.property('message');",
                      "        ",
                      "        const message = responseJson.message.toLowerCase();",
                      "        const hasConflictInfo = message.includes('exists') || ",
                      "                               message.includes('duplicate') || ",
                      "                               message.includes('conflict');",
                      "        pm.expect(hasConflictInfo).to.be.true;",
                      "        ",
                      "        console.log('‚úÖ Duplicate permission properly rejected');",
                      "    });",
                      "}",
                      "",
                      "// Security validation",
                      "pm.test('Security headers validation', function () {",
                      "    const headers = pm.response.headers;",
                      "    ",
                      "    // Content-Type should be JSON",
                      "    pm.expect(headers.get('Content-Type')).to.include('application/json');",
                      "    ",
                      "    console.log('üîí Security headers validated');",
                      "});",
                      "",
                      "// Performance validation",
                      "pm.test('Permission creation performance', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(2000);",
                      "    ",
                      "    if (pm.response.responseTime > 1000) {",
                      "        console.log('‚ö†Ô∏è Warning: Permission creation took longer than 1 second');",
                      "    } else {",
                      "        console.log('‚ö° Permission creation performance is good');",
                      "    }",
                      "});",
                      "",
                      "// Overall validation summary",
                      "console.log('üìä Permission Validation Suite Summary:');",
                      "console.log('  Status:', pm.response.status);",
                      "console.log('  Response Time:', pm.response.responseTime + 'ms');",
                      "console.log('  Content Length:', pm.response.headers.get('Content-Length') || 'Unknown');"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "üìÅ Project Management",
      "description": "Project lifecycle management within tenant context",
      "item": [
        {
          "name": "CRUD Operations",
          "description": "Complete project management operations",
          "item": [
            {
              "name": "Get All Projects",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text",
                    "description": "Tenant identifier - required for tenant isolation"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/projects",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "projects"
                  ]
                },
                "description": "Retrieve all projects in the current tenant. Requires 'read:project' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token with valid JWT\n- `x-tenant-id`: Tenant identifier\n\n**Required Permissions:** read:project\n\n**Response:**\n- Array of project objects with basic information\n- Each project includes id, name, description, ownerId, createdAt, updatedAt\n\n**Rate Limiting:** Standard API rate limits apply\n\n**Example Scenarios:**\n- Valid request: Returns 200 with projects array\n- No projects: Returns 200 with empty array\n- Missing permission: Returns 403 Forbidden\n- Invalid token: Returns 401 Unauthorized"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Get All Projects",
                      "",
                      "pm.test('Status code is 200', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});",
                      "",
                      "pm.test('Response is JSON array', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('array');",
                      "});",
                      "",
                      "pm.test('Projects have required fields', function () {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.length > 0) {",
                      "        const project = responseJson[0];",
                      "        pm.expect(project).to.have.property('id');",
                      "        pm.expect(project).to.have.property('name');",
                      "        pm.expect(project).to.have.property('ownerId');",
                      "        pm.expect(project).to.have.property('createdAt');",
                      "        pm.expect(project).to.have.property('updatedAt');",
                      "        ",
                      "        // Capture first project ID for subsequent tests",
                      "        pm.collectionVariables.set('projectId', project.id);",
                      "        console.log('‚úÖ Project ID captured:', project.id);",
                      "    }",
                      "});",
                      "",
                      "console.log('üìÅ Projects retrieved:', pm.response.json().length);"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Get All Projects",
                      "",
                      "// Validate required variables",
                      "const accessToken = pm.collectionVariables.get('accessToken');",
                      "const tenantId = pm.collectionVariables.get('tenantId');",
                      "",
                      "if (!accessToken) {",
                      "    console.log('‚ö†Ô∏è Warning: accessToken not set. Please authenticate first.');",
                      "}",
                      "",
                      "if (!tenantId) {",
                      "    console.log('‚ö†Ô∏è Warning: tenantId not set. Please set tenant context first.');",
                      "}",
                      "",
                      "console.log('üìÅ Fetching all projects for tenant:', tenantId);"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Get Project by ID",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text",
                    "description": "Tenant identifier - required for tenant isolation"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/projects/{{projectId}}",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "projects",
                    "{{projectId}}"
                  ]
                },
                "description": "Retrieve a specific project by its ID with detailed information. Requires 'read:project' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token with valid JWT\n- `x-tenant-id`: Tenant identifier\n\n**Path Parameters:**\n- `id`: Project ID (UUID format)\n\n**Required Permissions:** read:project\n\n**Response:**\n- Project object with detailed information\n- Includes id, name, description, ownerId, createdAt, updatedAt\n- May include owner information if populated\n\n**Example Scenarios:**\n- Valid project ID: Returns 200 with project details\n- Project not found: Returns 404 Not Found\n- Project in different tenant: Returns 404 Not Found (tenant isolation)\n- Missing permission: Returns 403 Forbidden\n- Invalid token: Returns 401 Unauthorized"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Get Project by ID",
                      "",
                      "pm.test('Status code is 200', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(2000);",
                      "});",
                      "",
                      "pm.test('Response contains project details', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('object');",
                      "    pm.expect(responseJson).to.have.property('id');",
                      "    pm.expect(responseJson).to.have.property('name');",
                      "    pm.expect(responseJson).to.have.property('ownerId');",
                      "    pm.expect(responseJson).to.have.property('createdAt');",
                      "    pm.expect(responseJson).to.have.property('updatedAt');",
                      "});",
                      "",
                      "pm.test('Project ID matches requested ID', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const requestedId = pm.collectionVariables.get('projectId');",
                      "    pm.expect(responseJson.id).to.equal(requestedId);",
                      "});",
                      "",
                      "console.log('üìÅ Project details retrieved for ID:', pm.response.json().id);"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Get Project by ID",
                      "",
                      "// Validate required variables",
                      "const accessToken = pm.collectionVariables.get('accessToken');",
                      "const tenantId = pm.collectionVariables.get('tenantId');",
                      "const projectId = pm.collectionVariables.get('projectId');",
                      "",
                      "if (!accessToken) {",
                      "    console.log('‚ö†Ô∏è Warning: accessToken not set. Please authenticate first.');",
                      "}",
                      "",
                      "if (!tenantId) {",
                      "    console.log('‚ö†Ô∏è Warning: tenantId not set. Please set tenant context first.');",
                      "}",
                      "",
                      "if (!projectId) {",
                      "    console.log('‚ö†Ô∏è Warning: projectId not set. Please create a project or get all projects first.');",
                      "    console.log('üí° Tip: Run \"Get All Projects\" first to capture a project ID');",
                      "}",
                      "",
                      "console.log('üìÅ Fetching project details for ID:', projectId);"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Create Project",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text",
                    "description": "Tenant identifier - required for tenant isolation"
                  },
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"name\": \"Sample Project\",\n  \"description\": \"This is a sample project for testing the API endpoints. It demonstrates project creation with proper metadata and owner assignment.\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/projects",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "projects"
                  ]
                },
                "description": "Create a new project in the current tenant. The authenticated user will be automatically set as the project owner. Requires 'create:project' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token with valid JWT\n- `x-tenant-id`: Tenant identifier\n- `Content-Type`: application/json\n\n**Required Permissions:** create:project\n\n**Request Body:**\n- `name`: Project name (required, string, 1-100 characters)\n- `description`: Project description (optional, string, max 500 characters)\n\n**Response:**\n- Created project object with generated ID\n- Includes id, name, description, ownerId (current user), createdAt, updatedAt\n\n**Owner Assignment:**\n- The current authenticated user is automatically assigned as the project owner\n- Owner has full permissions on the project\n\n**Example Scenarios:**\n- Valid request: Returns 201 with created project\n- Missing name: Returns 400 Bad Request\n- Name too long: Returns 400 Bad Request\n- Missing permission: Returns 403 Forbidden\n- Invalid token: Returns 401 Unauthorized"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Create Project",
                      "",
                      "pm.test('Status code is 201', function () {",
                      "    pm.expect(pm.response.code).to.equal(201);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});",
                      "",
                      "pm.test('Response contains created project', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('object');",
                      "    pm.expect(responseJson).to.have.property('id');",
                      "    pm.expect(responseJson).to.have.property('name');",
                      "    pm.expect(responseJson).to.have.property('ownerId');",
                      "    pm.expect(responseJson).to.have.property('createdAt');",
                      "    pm.expect(responseJson).to.have.property('updatedAt');",
                      "});",
                      "",
                      "pm.test('Project name matches request', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const requestBody = JSON.parse(pm.request.body.raw);",
                      "    pm.expect(responseJson.name).to.equal(requestBody.name);",
                      "});",
                      "",
                      "pm.test('Owner is current user', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const currentUserId = pm.collectionVariables.get('userId');",
                      "    if (currentUserId) {",
                      "        pm.expect(responseJson.ownerId).to.equal(currentUserId);",
                      "    }",
                      "});",
                      "",
                      "// Capture project ID for subsequent tests",
                      "pm.test('Project ID captured successfully', function () {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.id) {",
                      "        pm.collectionVariables.set('projectId', responseJson.id);",
                      "        console.log('‚úÖ Project ID captured:', responseJson.id);",
                      "        console.log('üìÅ Project created:', responseJson.name);",
                      "    }",
                      "});",
                      "",
                      "console.log('üìÅ Project creation completed successfully');"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Create Project",
                      "",
                      "// Validate required variables",
                      "const accessToken = pm.collectionVariables.get('accessToken');",
                      "const tenantId = pm.collectionVariables.get('tenantId');",
                      "",
                      "if (!accessToken) {",
                      "    console.log('‚ö†Ô∏è Warning: accessToken not set. Please authenticate first.');",
                      "}",
                      "",
                      "if (!tenantId) {",
                      "    console.log('‚ö†Ô∏è Warning: tenantId not set. Please set tenant context first.');",
                      "}",
                      "",
                      "// Generate unique project name for testing",
                      "const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, '');",
                      "const projectName = `Test Project ${timestamp}`;",
                      "",
                      "// Update request body with unique name",
                      "const requestBody = JSON.parse(pm.request.body.raw);",
                      "requestBody.name = projectName;",
                      "pm.request.body.raw = JSON.stringify(requestBody, null, 2);",
                      "",
                      "console.log('üìÅ Creating project:', projectName);"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Update Project",
              "request": {
                "method": "PUT",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text",
                    "description": "Tenant identifier - required for tenant isolation"
                  },
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"name\": \"Updated Project Name\",\n  \"description\": \"This project has been updated with new information. The description now includes additional details about the project scope and objectives.\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/projects/{{projectId}}",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "projects",
                    "{{projectId}}"
                  ]
                },
                "description": "Update an existing project's details. Supports partial updates - only provided fields will be updated. Requires 'update:project' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token with valid JWT\n- `x-tenant-id`: Tenant identifier\n- `Content-Type`: application/json\n\n**Path Parameters:**\n- `id`: Project ID (UUID format)\n\n**Required Permissions:** update:project\n\n**Request Body (all fields optional):**\n- `name`: Updated project name (string, 1-100 characters)\n- `description`: Updated project description (string, max 500 characters)\n\n**Response:**\n- Updated project object with new values\n- Includes id, name, description, ownerId, createdAt, updatedAt\n- updatedAt timestamp reflects the update time\n\n**Partial Updates:**\n- Only provided fields are updated\n- Omitted fields retain their current values\n- Empty strings are treated as valid updates\n\n**Example Scenarios:**\n- Valid update: Returns 200 with updated project\n- Project not found: Returns 404 Not Found\n- Project in different tenant: Returns 404 Not Found (tenant isolation)\n- Invalid field values: Returns 400 Bad Request\n- Missing permission: Returns 403 Forbidden\n- Invalid token: Returns 401 Unauthorized"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Update Project",
                      "",
                      "pm.test('Status code is 200', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});",
                      "",
                      "pm.test('Response contains updated project', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('object');",
                      "    pm.expect(responseJson).to.have.property('id');",
                      "    pm.expect(responseJson).to.have.property('name');",
                      "    pm.expect(responseJson).to.have.property('updatedAt');",
                      "});",
                      "",
                      "pm.test('Project fields updated correctly', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const requestBody = JSON.parse(pm.request.body.raw);",
                      "    ",
                      "    // Check if provided fields were updated",
                      "    if (requestBody.name) {",
                      "        pm.expect(responseJson.name).to.equal(requestBody.name);",
                      "    }",
                      "    if (requestBody.description) {",
                      "        pm.expect(responseJson.description).to.equal(requestBody.description);",
                      "    }",
                      "});",
                      "",
                      "pm.test('Project ID remains unchanged', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const originalId = pm.collectionVariables.get('projectId');",
                      "    pm.expect(responseJson.id).to.equal(originalId);",
                      "});",
                      "",
                      "pm.test('UpdatedAt timestamp is recent', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const updatedAt = new Date(responseJson.updatedAt);",
                      "    const now = new Date();",
                      "    const timeDiff = now - updatedAt;",
                      "    ",
                      "    // Should be updated within the last 10 seconds",
                      "    pm.expect(timeDiff).to.be.below(10000);",
                      "});",
                      "",
                      "console.log('üìÅ Project updated successfully:', pm.response.json().name);"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Update Project",
                      "",
                      "// Validate required variables",
                      "const accessToken = pm.collectionVariables.get('accessToken');",
                      "const tenantId = pm.collectionVariables.get('tenantId');",
                      "const projectId = pm.collectionVariables.get('projectId');",
                      "",
                      "if (!accessToken) {",
                      "    console.log('‚ö†Ô∏è Warning: accessToken not set. Please authenticate first.');",
                      "}",
                      "",
                      "if (!tenantId) {",
                      "    console.log('‚ö†Ô∏è Warning: tenantId not set. Please set tenant context first.');",
                      "}",
                      "",
                      "if (!projectId) {",
                      "    console.log('‚ö†Ô∏è Warning: projectId not set. Please create a project first.');",
                      "    console.log('üí° Tip: Run \"Create Project\" first to get a project ID');",
                      "}",
                      "",
                      "// Add timestamp to make the update unique",
                      "const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, '');",
                      "const requestBody = JSON.parse(pm.request.body.raw);",
                      "requestBody.name = `Updated Project ${timestamp}`;",
                      "pm.request.body.raw = JSON.stringify(requestBody, null, 2);",
                      "",
                      "console.log('üìÅ Updating project ID:', projectId);"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Delete Project",
              "request": {
                "method": "DELETE",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text",
                    "description": "Tenant identifier - required for tenant isolation"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/projects/{{projectId}}",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "projects",
                    "{{projectId}}"
                  ]
                },
                "description": "Delete an existing project permanently. This action cannot be undone. Requires 'delete:project' permission.\n\n**Required Headers:**\n- `Authorization`: Bearer token with valid JWT\n- `x-tenant-id`: Tenant identifier\n\n**Path Parameters:**\n- `id`: Project ID (UUID format)\n\n**Required Permissions:** delete:project\n\n**Response:**\n- Success confirmation message\n- HTTP 200 status code\n\n**Important Notes:**\n- This operation is permanent and cannot be undone\n- All project-related data may be affected\n- Consider backing up important project data before deletion\n- Tenant isolation ensures only projects within the current tenant can be deleted\n\n**Example Scenarios:**\n- Valid deletion: Returns 200 with success message\n- Project not found: Returns 404 Not Found\n- Project in different tenant: Returns 404 Not Found (tenant isolation)\n- Missing permission: Returns 403 Forbidden\n- Invalid token: Returns 401 Unauthorized"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for Delete Project",
                      "",
                      "pm.test('Status code is 200', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});",
                      "",
                      "pm.test('Response confirms deletion', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('object');",
                      "    // Response should indicate successful deletion",
                      "    const responseText = JSON.stringify(responseJson).toLowerCase();",
                      "    const hasSuccessIndicator = responseText.includes('success') || ",
                      "                               responseText.includes('deleted') || ",
                      "                               responseText.includes('removed');",
                      "    pm.expect(hasSuccessIndicator).to.be.true;",
                      "});",
                      "",
                      "// Clear the project ID since it's been deleted",
                      "pm.test('Project ID cleared after deletion', function () {",
                      "    pm.collectionVariables.set('projectId', '');",
                      "    console.log('üóëÔ∏è Project ID cleared from variables');",
                      "});",
                      "",
                      "console.log('üóëÔ∏è Project deleted successfully');"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for Delete Project",
                      "",
                      "// Validate required variables",
                      "const accessToken = pm.collectionVariables.get('accessToken');",
                      "const tenantId = pm.collectionVariables.get('tenantId');",
                      "const projectId = pm.collectionVariables.get('projectId');",
                      "",
                      "if (!accessToken) {",
                      "    console.log('‚ö†Ô∏è Warning: accessToken not set. Please authenticate first.');",
                      "}",
                      "",
                      "if (!tenantId) {",
                      "    console.log('‚ö†Ô∏è Warning: tenantId not set. Please set tenant context first.');",
                      "}",
                      "",
                      "if (!projectId) {",
                      "    console.log('‚ö†Ô∏è Warning: projectId not set. Please create a project first.');",
                      "    console.log('üí° Tip: Run \"Create Project\" first to get a project ID');",
                      "}",
                      "",
                      "console.log('üóëÔ∏è Deleting project ID:', projectId);",
                      "console.log('‚ö†Ô∏è Warning: This action cannot be undone!');"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Create Project - Validation Examples",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  },
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"name\": \"\",\n  \"description\": \"This request demonstrates validation by providing an empty name, which should trigger a 400 Bad Request response.\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/projects",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "projects"
                  ]
                },
                "description": "Example of project creation with invalid data to demonstrate validation handling. This request uses an empty name which should trigger validation errors.\n\n**Expected Response:** 400 Bad Request\n**Use Case:** Testing input validation and error handling\n\n**Validation Rules Tested:**\n- Name is required (cannot be empty)\n- Name length validation\n- Field type validation\n\n**Other Validation Examples:**\n- Try with name longer than 100 characters\n- Try with invalid data types\n- Try with missing required fields"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for validation example",
                      "",
                      "pm.test('Validation error returns 400 Bad Request', function () {",
                      "    pm.expect(pm.response.code).to.equal(400);",
                      "});",
                      "",
                      "pm.test('Error response has validation message', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('message');",
                      "    ",
                      "    // Should mention validation or name requirement",
                      "    const message = responseJson.message.toLowerCase();",
                      "    const hasValidationInfo = message.includes('name') || ",
                      "                             message.includes('required') || ",
                      "                             message.includes('validation');",
                      "    pm.expect(hasValidationInfo).to.be.true;",
                      "});",
                      "",
                      "pm.test('No project created on validation error', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.not.have.property('id');",
                      "});",
                      "",
                      "console.log('‚úÖ Validation error properly handled');"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "name": "üîî Notification System",
      "description": "Comprehensive notification system with preferences and broadcasting",
      "item": [
        {
          "name": "Notification CRUD",
          "description": "Create, read, update, and delete notifications",
          "item": [
            {
              "name": "Create Notification",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text",
                    "description": "Tenant identifier - required for tenant isolation"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"userId\": \"{{userId}}\",\n  \"type\": \"INFO\",\n  \"category\": \"system\",\n  \"title\": \"Welcome to the platform\",\n  \"message\": \"Your account has been successfully created and you can now access all features.\",\n  \"data\": {\n    \"actionUrl\": \"/dashboard\",\n    \"priority\": \"normal\",\n    \"source\": \"user_registration\"\n  },\n  \"priority\": \"MEDIUM\",\n  \"expiresAt\": \"2024-12-31T23:59:59.000Z\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/notifications",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "notifications"
                  ]
                },
                "description": "Create a new notification for a specific user. This endpoint allows creating notifications with various types, categories, and optional metadata.\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n- `Content-Type`: application/json\n\n**Request Body:**\n- `userId`: Target user ID (required)\n- `type`: Notification type - INFO, WARNING, SUCCESS, ERROR (required)\n- `category`: Notification category for grouping (required)\n- `title`: Notification title (required, max 255 chars)\n- `message`: Notification message content (required, max 1000 chars)\n- `data`: Additional metadata object (optional)\n- `priority`: Priority level - LOW, MEDIUM, HIGH, URGENT (optional)\n- `expiresAt`: Expiration date in ISO format (optional)\n\n**Rate Limiting:** 10 notifications per minute per user\n\n**Example Scenarios:**\n- System notifications: Welcome messages, account updates\n- Business notifications: Invoice generated, payment received\n- Alert notifications: Security warnings, system maintenance\n- Promotional notifications: Feature announcements, offers"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for notification creation",
                      "",
                      "pm.test('Notification created successfully', function () {",
                      "    pm.expect(pm.response.code).to.equal(201);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});",
                      "",
                      "pm.test('Response has correct content type', function () {",
                      "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                      "});",
                      "",
                      "pm.test('Response contains notification data', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('id');",
                      "    pm.expect(responseJson).to.have.property('tenantId');",
                      "    pm.expect(responseJson).to.have.property('userId');",
                      "    pm.expect(responseJson).to.have.property('type');",
                      "    pm.expect(responseJson).to.have.property('category');",
                      "    pm.expect(responseJson).to.have.property('title');",
                      "    pm.expect(responseJson).to.have.property('message');",
                      "    pm.expect(responseJson).to.have.property('createdAt');",
                      "});",
                      "",
                      "// Capture notification ID for subsequent requests",
                      "pm.test('Notification ID captured successfully', function () {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.id) {",
                      "        pm.collectionVariables.set('notificationId', responseJson.id);",
                      "        console.log('‚úÖ Notification ID captured:', responseJson.id);",
                      "    }",
                      "});",
                      "",
                      "// Validate notification structure",
                      "pm.test('Notification has valid structure', function () {",
                      "    const responseJson = pm.response.json();",
                      "    ",
                      "    // Validate required fields",
                      "    pm.expect(responseJson.id).to.be.a('string');",
                      "    pm.expect(responseJson.tenantId).to.equal(pm.collectionVariables.get('tenantId'));",
                      "    pm.expect(responseJson.userId).to.equal(pm.collectionVariables.get('userId'));",
                      "    pm.expect(responseJson.type).to.be.oneOf(['INFO', 'WARNING', 'SUCCESS', 'ERROR']);",
                      "    pm.expect(responseJson.category).to.be.a('string');",
                      "    pm.expect(responseJson.title).to.be.a('string');",
                      "    pm.expect(responseJson.message).to.be.a('string');",
                      "    ",
                      "    // Validate timestamps",
                      "    pm.expect(responseJson.createdAt).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/);",
                      "    ",
                      "    console.log('‚úÖ Notification structure validation passed');",
                      "});",
                      "",
                      "// Log creation status",
                      "if (pm.response.code === 201) {",
                      "    console.log('üîî Notification created successfully');",
                      "} else if (pm.response.code === 429) {",
                      "    console.log('‚ö†Ô∏è Rate limit exceeded - Wait before creating more notifications');",
                      "} else if (pm.response.code === 401) {",
                      "    console.log('‚ùå Authentication required - Check access token');",
                      "} else if (pm.response.code === 400) {",
                      "    console.log('‚ùå Bad request - Check request body and tenant ID');",
                      "}"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for notification creation",
                      "",
                      "// Ensure required variables are set",
                      "const userId = pm.collectionVariables.get('userId');",
                      "const tenantId = pm.collectionVariables.get('tenantId');",
                      "const accessToken = pm.collectionVariables.get('accessToken');",
                      "",
                      "if (!userId) {",
                      "    console.log('‚ö†Ô∏è Warning: userId not set. Please authenticate first.');",
                      "}",
                      "",
                      "if (!tenantId) {",
                      "    console.log('‚ö†Ô∏è Warning: tenantId not set. Please set tenant context.');",
                      "}",
                      "",
                      "if (!accessToken) {",
                      "    console.log('‚ö†Ô∏è Warning: accessToken not set. Please authenticate first.');",
                      "}",
                      "",
                      "// Log request details",
                      "console.log('üîî Creating notification for user:', userId);",
                      "console.log('üìã Request details:', {",
                      "    tenantId: tenantId,",
                      "    hasAuth: !!accessToken",
                      "});"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Get User Notifications",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text",
                    "description": "Tenant identifier - required for tenant isolation"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/notifications?page=1&limit=20&sortBy=createdAt&sortOrder=desc",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "notifications"
                  ],
                  "query": [
                    {
                      "key": "page",
                      "value": "1",
                      "description": "Page number for pagination (default: 1)"
                    },
                    {
                      "key": "limit",
                      "value": "20",
                      "description": "Number of items per page (max: 100, default: 20)"
                    },
                    {
                      "key": "type",
                      "value": "",
                      "description": "Filter by notification type (INFO, WARNING, SUCCESS, ERROR)",
                      "disabled": true
                    },
                    {
                      "key": "category",
                      "value": "",
                      "description": "Filter by notification category",
                      "disabled": true
                    },
                    {
                      "key": "unread",
                      "value": "",
                      "description": "Filter by read status (true for read, false for unread)",
                      "disabled": true
                    },
                    {
                      "key": "sortBy",
                      "value": "createdAt",
                      "description": "Sort field (createdAt, readAt, title, type)"
                    },
                    {
                      "key": "sortOrder",
                      "value": "desc",
                      "description": "Sort order (asc, desc)"
                    },
                    {
                      "key": "search",
                      "value": "",
                      "description": "Search term for title and message",
                      "disabled": true
                    }
                  ]
                },
                "description": "Get paginated list of notifications for the current authenticated user with comprehensive filtering and sorting options.\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n\n**Query Parameters:**\n- `page`: Page number (default: 1, min: 1)\n- `limit`: Items per page (default: 20, max: 100)\n- `type`: Filter by notification type (INFO, WARNING, SUCCESS, ERROR)\n- `category`: Filter by notification category\n- `unread`: Filter by read status (true/false)\n- `sortBy`: Sort field (createdAt, readAt, title, type)\n- `sortOrder`: Sort direction (asc, desc)\n- `search`: Search in title and message content\n\n**Rate Limiting:** 100 requests per minute\n\n**Response Structure:**\n- `notifications`: Array of notification objects\n- `total`: Total number of notifications\n- `page`: Current page number\n- `limit`: Items per page\n- `totalPages`: Total number of pages\n\n**Example Use Cases:**\n- Get recent notifications: Default sorting by createdAt desc\n- Get unread notifications: Set unread=false\n- Search notifications: Use search parameter\n- Filter by type: Set type parameter for specific notification types"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for getting user notifications",
                      "",
                      "pm.test('Notifications retrieved successfully', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});",
                      "",
                      "pm.test('Response has correct content type', function () {",
                      "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                      "});",
                      "",
                      "pm.test('Response has pagination structure', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('notifications');",
                      "    pm.expect(responseJson).to.have.property('total');",
                      "    pm.expect(responseJson).to.have.property('page');",
                      "    pm.expect(responseJson).to.have.property('limit');",
                      "    pm.expect(responseJson).to.have.property('totalPages');",
                      "});",
                      "",
                      "pm.test('Notifications array is valid', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson.notifications).to.be.an('array');",
                      "    ",
                      "    // If notifications exist, validate structure",
                      "    if (responseJson.notifications.length > 0) {",
                      "        const notification = responseJson.notifications[0];",
                      "        pm.expect(notification).to.have.property('id');",
                      "        pm.expect(notification).to.have.property('tenantId');",
                      "        pm.expect(notification).to.have.property('userId');",
                      "        pm.expect(notification).to.have.property('type');",
                      "        pm.expect(notification).to.have.property('category');",
                      "        pm.expect(notification).to.have.property('title');",
                      "        pm.expect(notification).to.have.property('message');",
                      "        pm.expect(notification).to.have.property('createdAt');",
                      "        ",
                      "        // Capture first notification ID if available",
                      "        if (!pm.collectionVariables.get('notificationId')) {",
                      "            pm.collectionVariables.set('notificationId', notification.id);",
                      "            console.log('‚úÖ Notification ID captured from list:', notification.id);",
                      "        }",
                      "    }",
                      "});",
                      "",
                      "pm.test('Pagination values are valid', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson.page).to.be.a('number');",
                      "    pm.expect(responseJson.limit).to.be.a('number');",
                      "    pm.expect(responseJson.total).to.be.a('number');",
                      "    pm.expect(responseJson.totalPages).to.be.a('number');",
                      "    ",
                      "    // Validate pagination logic",
                      "    pm.expect(responseJson.page).to.be.at.least(1);",
                      "    pm.expect(responseJson.limit).to.be.at.least(1);",
                      "    pm.expect(responseJson.total).to.be.at.least(0);",
                      "    pm.expect(responseJson.totalPages).to.be.at.least(0);",
                      "});",
                      "",
                      "// Log retrieval status",
                      "const responseJson = pm.response.json();",
                      "console.log('üìã Retrieved notifications:', {",
                      "    count: responseJson.notifications.length,",
                      "    total: responseJson.total,",
                      "    page: responseJson.page,",
                      "    totalPages: responseJson.totalPages",
                      "});",
                      "",
                      "if (responseJson.notifications.length === 0) {",
                      "    console.log('üì≠ No notifications found for current user');",
                      "} else {",
                      "    console.log('‚úÖ Notifications retrieved successfully');",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Get User Notifications - With Filters",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/notifications?page=1&limit=10&type=INFO&unread=false&search=welcome&sortBy=createdAt&sortOrder=desc",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "notifications"
                  ],
                  "query": [
                    {
                      "key": "page",
                      "value": "1"
                    },
                    {
                      "key": "limit",
                      "value": "10"
                    },
                    {
                      "key": "type",
                      "value": "INFO"
                    },
                    {
                      "key": "unread",
                      "value": "false"
                    },
                    {
                      "key": "search",
                      "value": "welcome"
                    },
                    {
                      "key": "sortBy",
                      "value": "createdAt"
                    },
                    {
                      "key": "sortOrder",
                      "value": "desc"
                    }
                  ]
                },
                "description": "Example of getting notifications with comprehensive filtering applied. This demonstrates how to use multiple query parameters to filter and search notifications.\n\n**Applied Filters:**\n- Type: INFO notifications only\n- Status: Unread notifications only\n- Search: Contains 'welcome' in title or message\n- Sorting: By creation date, newest first\n- Pagination: First 10 results\n\n**Use Case:** Finding specific notifications with advanced filtering"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "pm.test('Filtered notifications retrieved', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Filters applied correctly', function () {",
                      "    const responseJson = pm.response.json();",
                      "    ",
                      "    // Check if notifications match filters",
                      "    responseJson.notifications.forEach(notification => {",
                      "        // Type filter",
                      "        pm.expect(notification.type).to.equal('INFO');",
                      "        ",
                      "        // Unread filter (readAt should be null for unread)",
                      "        pm.expect(notification.readAt).to.be.null;",
                      "        ",
                      "        // Search filter (title or message should contain 'welcome')",
                      "        const searchTerm = 'welcome';",
                      "        const titleMatch = notification.title.toLowerCase().includes(searchTerm);",
                      "        const messageMatch = notification.message.toLowerCase().includes(searchTerm);",
                      "        pm.expect(titleMatch || messageMatch).to.be.true;",
                      "    });",
                      "});",
                      "",
                      "console.log('üîç Filtered notifications test completed');"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Get Notification by ID",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/notifications/{{notificationId}}",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "notifications",
                    "{{notificationId}}"
                  ]
                },
                "description": "Get a specific notification by its ID. Users can only access their own notifications due to ownership validation.\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n\n**Path Parameters:**\n- `id`: Notification ID (automatically captured from previous requests)\n\n**Security:**\n- Ownership validation ensures users can only access their own notifications\n- Tenant isolation prevents cross-tenant access\n\n**Response:** Single notification object with all details\n\n**Error Cases:**\n- 404: Notification not found or access denied\n- 401: Authentication required\n- 403: Insufficient permissions"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for getting notification by ID",
                      "",
                      "pm.test('Notification retrieved by ID successfully', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(2000);",
                      "});",
                      "",
                      "pm.test('Response contains notification details', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('id');",
                      "    pm.expect(responseJson).to.have.property('tenantId');",
                      "    pm.expect(responseJson).to.have.property('userId');",
                      "    pm.expect(responseJson).to.have.property('type');",
                      "    pm.expect(responseJson).to.have.property('category');",
                      "    pm.expect(responseJson).to.have.property('title');",
                      "    pm.expect(responseJson).to.have.property('message');",
                      "    pm.expect(responseJson).to.have.property('createdAt');",
                      "});",
                      "",
                      "pm.test('Notification belongs to current user', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const currentUserId = pm.collectionVariables.get('userId');",
                      "    pm.expect(responseJson.userId).to.equal(currentUserId);",
                      "});",
                      "",
                      "pm.test('Notification belongs to current tenant', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const currentTenantId = pm.collectionVariables.get('tenantId');",
                      "    pm.expect(responseJson.tenantId).to.equal(currentTenantId);",
                      "});",
                      "",
                      "// Log notification details",
                      "if (pm.response.code === 200) {",
                      "    const notification = pm.response.json();",
                      "    console.log('üìã Notification details:', {",
                      "        id: notification.id,",
                      "        type: notification.type,",
                      "        category: notification.category,",
                      "        title: notification.title,",
                      "        isRead: !!notification.readAt",
                      "    });",
                      "    console.log('‚úÖ Notification retrieved successfully');",
                      "} else if (pm.response.code === 404) {",
                      "    console.log('‚ùå Notification not found or access denied');",
                      "}"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for getting notification by ID",
                      "",
                      "const notificationId = pm.collectionVariables.get('notificationId');",
                      "if (!notificationId) {",
                      "    console.log('‚ö†Ô∏è Warning: notificationId not set. Please create a notification first or set the ID manually.');",
                      "    console.log('üí° Tip: Run \"Create Notification\" or \"Get User Notifications\" first to capture an ID');",
                      "}",
                      "",
                      "console.log('üîç Retrieving notification:', notificationId);"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Mark Notification as Read",
              "request": {
                "method": "PATCH",
                "header": [
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/notifications/{{notificationId}}/read",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "notifications",
                    "{{notificationId}}",
                    "read"
                  ]
                },
                "description": "Mark a specific notification as read. This updates the readAt timestamp and affects unread count calculations.\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n\n**Path Parameters:**\n- `id`: Notification ID to mark as read\n\n**Security:**\n- Ownership validation ensures users can only mark their own notifications\n- Tenant isolation prevents cross-tenant access\n\n**Rate Limiting:** 50 mark-as-read operations per minute\n\n**Response:** Success confirmation message\n\n**Use Cases:**\n- User clicks on notification to read it\n- Bulk read operations (use mark-all-as-read for efficiency)\n- Notification interaction tracking"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for marking notification as read",
                      "",
                      "pm.test('Notification marked as read successfully', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(2000);",
                      "});",
                      "",
                      "pm.test('Response contains success confirmation', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('success');",
                      "    pm.expect(responseJson).to.have.property('message');",
                      "    pm.expect(responseJson.success).to.be.true;",
                      "});",
                      "",
                      "// Log mark as read status",
                      "if (pm.response.code === 200) {",
                      "    console.log('‚úÖ Notification marked as read successfully');",
                      "} else if (pm.response.code === 404) {",
                      "    console.log('‚ùå Notification not found or access denied');",
                      "} else if (pm.response.code === 429) {",
                      "    console.log('‚ö†Ô∏è Rate limit exceeded - Too many mark-as-read operations');",
                      "}"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for marking notification as read",
                      "",
                      "const notificationId = pm.collectionVariables.get('notificationId');",
                      "if (!notificationId) {",
                      "    console.log('‚ö†Ô∏è Warning: notificationId not set. Please create a notification first.');",
                      "}",
                      "",
                      "console.log('üìñ Marking notification as read:', notificationId);"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Mark All Notifications as Read",
              "request": {
                "method": "PATCH",
                "header": [
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/notifications/read-all",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "notifications",
                    "read-all"
                  ]
                },
                "description": "Mark all unread notifications as read for the current authenticated user. This is a bulk operation that updates all unread notifications at once.\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n\n**Rate Limiting:** 10 mark-all-as-read operations per minute\n\n**Response:** Success confirmation message\n\n**Use Cases:**\n- \"Mark all as read\" button functionality\n- Bulk notification management\n- Clearing notification badges/counters\n- User preference for batch operations\n\n**Performance:** Optimized for bulk updates, more efficient than individual mark-as-read calls"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for marking all notifications as read",
                      "",
                      "pm.test('All notifications marked as read successfully', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});",
                      "",
                      "pm.test('Response contains success confirmation', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('success');",
                      "    pm.expect(responseJson).to.have.property('message');",
                      "    pm.expect(responseJson.success).to.be.true;",
                      "});",
                      "",
                      "// Log bulk mark as read status",
                      "if (pm.response.code === 200) {",
                      "    console.log('‚úÖ All notifications marked as read successfully');",
                      "} else if (pm.response.code === 429) {",
                      "    console.log('‚ö†Ô∏è Rate limit exceeded - Too many bulk operations');",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Get Unread Notification Count",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/notifications/unread-count",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "notifications",
                    "unread-count"
                  ]
                },
                "description": "Get the count of unread notifications for the current authenticated user. This is optimized for frequent polling and badge display.\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n\n**Rate Limiting:** 60 requests per minute (optimized for frequent polling)\n\n**Response:** Object with count property\n\n**Use Cases:**\n- Notification badge counters in UI\n- Real-time notification status updates\n- Dashboard widgets showing unread counts\n- Mobile app badge numbers\n- Periodic polling for notification status\n\n**Performance:** Highly optimized query for fast response times"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for getting unread notification count",
                      "",
                      "pm.test('Unread count retrieved successfully', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response time is fast (optimized for polling)', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(1000);",
                      "});",
                      "",
                      "pm.test('Response contains count', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('count');",
                      "    pm.expect(responseJson.count).to.be.a('number');",
                      "    pm.expect(responseJson.count).to.be.at.least(0);",
                      "});",
                      "",
                      "// Log unread count",
                      "const responseJson = pm.response.json();",
                      "console.log('üìä Unread notification count:', responseJson.count);",
                      "",
                      "if (responseJson.count === 0) {",
                      "    console.log('üì≠ No unread notifications');",
                      "} else if (responseJson.count === 1) {",
                      "    console.log('üì¨ 1 unread notification');",
                      "} else {",
                      "    console.log(`üì¨ ${responseJson.count} unread notifications`);",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Delete Notification",
              "request": {
                "method": "DELETE",
                "header": [
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/notifications/{{notificationId}}",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "notifications",
                    "{{notificationId}}"
                  ]
                },
                "description": "Delete (dismiss) a specific notification. This performs a soft delete for privacy and audit purposes.\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n\n**Path Parameters:**\n- `id`: Notification ID to delete\n\n**Security:**\n- Ownership validation ensures users can only delete their own notifications\n- Tenant isolation prevents cross-tenant access\n- Soft delete maintains audit trail\n\n**Rate Limiting:** 30 delete operations per minute\n\n**Response:** Success confirmation message\n\n**Use Cases:**\n- User dismisses notification from UI\n- Cleanup of old or irrelevant notifications\n- Privacy-focused notification management\n- Notification list management"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for deleting notification",
                      "",
                      "pm.test('Notification deleted successfully', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(2000);",
                      "});",
                      "",
                      "pm.test('Response contains success confirmation', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('success');",
                      "    pm.expect(responseJson).to.have.property('message');",
                      "    pm.expect(responseJson.success).to.be.true;",
                      "});",
                      "",
                      "// Log deletion status",
                      "if (pm.response.code === 200) {",
                      "    console.log('‚úÖ Notification deleted successfully');",
                      "    // Clear the notification ID since it's been deleted",
                      "    pm.collectionVariables.set('notificationId', '');",
                      "    console.log('üßπ Cleared notificationId variable');",
                      "} else if (pm.response.code === 404) {",
                      "    console.log('‚ùå Notification not found or access denied');",
                      "} else if (pm.response.code === 429) {",
                      "    console.log('‚ö†Ô∏è Rate limit exceeded - Too many delete operations');",
                      "}"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for deleting notification",
                      "",
                      "const notificationId = pm.collectionVariables.get('notificationId');",
                      "if (!notificationId) {",
                      "    console.log('‚ö†Ô∏è Warning: notificationId not set. Please create a notification first.');",
                      "}",
                      "",
                      "console.log('üóëÔ∏è Deleting notification:', notificationId);"
                    ]
                  }
                }
              ]
            }
          ]
        },
        {
          "name": "Notification Preferences",
          "description": "Manage user notification preferences by category and channel",
          "item": [
            {
              "name": "Get User Notification Preferences",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text",
                    "description": "Tenant identifier - required for tenant isolation"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/notification-preferences",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "notification-preferences"
                  ]
                },
                "description": "Get all notification preferences for the current authenticated user. Returns preferences for each category and channel combination.\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n\n**Rate Limiting:** 30 requests per minute\n\n**Response Structure:**\nArray of preference objects, each containing:\n- `id`: Preference record ID\n- `tenantId`: Tenant identifier\n- `userId`: User identifier\n- `category`: Notification category (e.g., 'invoice', 'system', 'security')\n- `inAppEnabled`: Boolean for in-app notification preference\n- `emailEnabled`: Boolean for email notification preference\n- `smsEnabled`: Boolean for SMS notification preference\n- `createdAt`: Creation timestamp\n- `updatedAt`: Last update timestamp\n\n**Use Cases:**\n- Display user preference settings in UI\n- Initialize preference management forms\n- Audit user notification settings\n- Sync preferences across devices\n\n**Default Behavior:**\n- New users get default preferences for all categories\n- Missing categories are created with default settings\n- Preferences are tenant-isolated"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for getting user notification preferences",
                      "",
                      "pm.test('Notification preferences retrieved successfully', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(2000);",
                      "});",
                      "",
                      "pm.test('Response has correct content type', function () {",
                      "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                      "});",
                      "",
                      "pm.test('Response is an array of preferences', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('array');",
                      "});",
                      "",
                      "pm.test('Preferences have valid structure', function () {",
                      "    const responseJson = pm.response.json();",
                      "    ",
                      "    if (responseJson.length > 0) {",
                      "        const preference = responseJson[0];",
                      "        pm.expect(preference).to.have.property('id');",
                      "        pm.expect(preference).to.have.property('tenantId');",
                      "        pm.expect(preference).to.have.property('userId');",
                      "        pm.expect(preference).to.have.property('category');",
                      "        pm.expect(preference).to.have.property('inAppEnabled');",
                      "        pm.expect(preference).to.have.property('emailEnabled');",
                      "        pm.expect(preference).to.have.property('smsEnabled');",
                      "        pm.expect(preference).to.have.property('createdAt');",
                      "        pm.expect(preference).to.have.property('updatedAt');",
                      "        ",
                      "        // Validate data types",
                      "        pm.expect(preference.id).to.be.a('string');",
                      "        pm.expect(preference.tenantId).to.equal(pm.collectionVariables.get('tenantId'));",
                      "        pm.expect(preference.userId).to.equal(pm.collectionVariables.get('userId'));",
                      "        pm.expect(preference.category).to.be.a('string');",
                      "        pm.expect(preference.inAppEnabled).to.be.a('boolean');",
                      "        pm.expect(preference.emailEnabled).to.be.a('boolean');",
                      "        pm.expect(preference.smsEnabled).to.be.a('boolean');",
                      "    }",
                      "});",
                      "",
                      "pm.test('All preferences belong to current user and tenant', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const currentUserId = pm.collectionVariables.get('userId');",
                      "    const currentTenantId = pm.collectionVariables.get('tenantId');",
                      "    ",
                      "    responseJson.forEach(preference => {",
                      "        pm.expect(preference.userId).to.equal(currentUserId);",
                      "        pm.expect(preference.tenantId).to.equal(currentTenantId);",
                      "    });",
                      "});",
                      "",
                      "// Log preferences summary",
                      "const responseJson = pm.response.json();",
                      "console.log('‚öôÔ∏è User notification preferences retrieved');",
                      "console.log('üìä Preferences summary:', {",
                      "    totalCategories: responseJson.length,",
                      "    userId: pm.collectionVariables.get('userId'),",
                      "    tenantId: pm.collectionVariables.get('tenantId')",
                      "});",
                      "",
                      "if (responseJson.length === 0) {",
                      "    console.log('üì≠ No preferences found - User may need default preferences created');",
                      "} else {",
                      "    console.log('‚úÖ Preferences loaded successfully');",
                      "    ",
                      "    // Log category breakdown",
                      "    const categories = responseJson.map(p => p.category);",
                      "    console.log('üìã Categories configured:', categories.join(', '));",
                      "    ",
                      "    // Log channel usage summary",
                      "    const channelStats = {",
                      "        inApp: responseJson.filter(p => p.inAppEnabled).length,",
                      "        email: responseJson.filter(p => p.emailEnabled).length,",
                      "        sms: responseJson.filter(p => p.smsEnabled).length",
                      "    };",
                      "    console.log('üì± Channel usage:', channelStats);",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Get Available Notification Categories",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text",
                    "description": "Tenant identifier - required for tenant isolation"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/notification-preferences/categories",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "notification-preferences",
                    "categories"
                  ]
                },
                "description": "Get list of all available notification categories for the current tenant. This is used to populate preference management interfaces.\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n\n**Rate Limiting:** 20 requests per minute\n\n**Response Structure:**\n- `categories`: Array of category strings\n\n**Common Categories:**\n- `user_activity`: User actions and interactions\n- `system`: System notifications and updates\n- `invoice`: Billing and payment notifications\n- `project`: Project-related notifications\n- `security`: Security alerts and warnings\n- `announcement`: Company announcements\n- `feature_announcement`: New feature releases\n- `maintenance`: System maintenance notifications\n\n**Use Cases:**\n- Populate preference management UI\n- Validate category names in forms\n- Display available notification types\n- Initialize new user preferences\n\n**Tenant Isolation:**\n- Categories may vary by tenant configuration\n- Custom categories can be tenant-specific"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for getting notification categories",
                      "",
                      "pm.test('Notification categories retrieved successfully', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(1500);",
                      "});",
                      "",
                      "pm.test('Response has correct content type', function () {",
                      "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                      "});",
                      "",
                      "pm.test('Response contains categories array', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('categories');",
                      "    pm.expect(responseJson.categories).to.be.an('array');",
                      "});",
                      "",
                      "pm.test('Categories are valid strings', function () {",
                      "    const responseJson = pm.response.json();",
                      "    ",
                      "    responseJson.categories.forEach(category => {",
                      "        pm.expect(category).to.be.a('string');",
                      "        pm.expect(category.length).to.be.greaterThan(0);",
                      "    });",
                      "});",
                      "",
                      "pm.test('Common categories are present', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const categories = responseJson.categories;",
                      "    ",
                      "    // Check for some expected common categories",
                      "    const expectedCategories = ['system', 'user_activity', 'security'];",
                      "    const hasCommonCategories = expectedCategories.some(expected => ",
                      "        categories.includes(expected)",
                      "    );",
                      "    ",
                      "    pm.expect(hasCommonCategories).to.be.true;",
                      "});",
                      "",
                      "// Log categories information",
                      "const responseJson = pm.response.json();",
                      "console.log('üìã Available notification categories retrieved');",
                      "console.log('üìä Categories summary:', {",
                      "    totalCategories: responseJson.categories.length,",
                      "    tenantId: pm.collectionVariables.get('tenantId')",
                      "});",
                      "",
                      "if (responseJson.categories.length === 0) {",
                      "    console.log('‚ö†Ô∏è No categories found - Check tenant configuration');",
                      "} else {",
                      "    console.log('‚úÖ Categories loaded successfully');",
                      "    console.log('üìã Available categories:', responseJson.categories.join(', '));",
                      "    ",
                      "    // Store first category for testing preferences",
                      "    if (responseJson.categories.length > 0) {",
                      "        pm.collectionVariables.set('testCategory', responseJson.categories[0]);",
                      "        console.log('üíæ Stored test category:', responseJson.categories[0]);",
                      "    }",
                      "}"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Update Notification Preferences for Category",
              "request": {
                "method": "PUT",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text",
                    "description": "Tenant identifier - required for tenant isolation"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"inAppEnabled\": true,\n  \"emailEnabled\": true,\n  \"smsEnabled\": false\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/notification-preferences/{{testCategory}}",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "notification-preferences",
                    "{{testCategory}}"
                  ]
                },
                "description": "Update notification channel preferences for a specific category. This allows users to control which channels they receive notifications through for each category.\n\n**Required Headers:**\n- `Authorization`: Bearer token\n- `x-tenant-id`: Tenant identifier\n- `Content-Type`: application/json\n\n**Path Parameters:**\n- `category`: Notification category to update (e.g., 'system', 'invoice', 'security')\n\n**Request Body (all fields optional):**\n- `inAppEnabled`: Enable/disable in-app notifications (boolean)\n- `emailEnabled`: Enable/disable email notifications (boolean)\n- `smsEnabled`: Enable/disable SMS notifications (boolean)\n\n**Rate Limiting:** 20 preference updates per minute\n\n**Response:** Updated preference object with all current settings\n\n**Use Cases:**\n- User toggles notification channels in settings\n- Bulk preference updates during onboarding\n- Privacy-focused notification management\n- Channel-specific opt-out functionality\n\n**Validation:**\n- At least one field must be provided\n- Category must exist in available categories\n- Boolean values required for all channel fields\n\n**Examples:**\n- Disable all email: `{\"emailEnabled\": false}`\n- Enable only in-app: `{\"inAppEnabled\": true, \"emailEnabled\": false, \"smsEnabled\": false}`\n- Update single channel: `{\"smsEnabled\": true}`"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for updating notification preferences",
                      "",
                      "pm.test('Notification preferences updated successfully', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(2000);",
                      "});",
                      "",
                      "pm.test('Response has correct content type', function () {",
                      "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                      "});",
                      "",
                      "pm.test('Response contains updated preference', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('id');",
                      "    pm.expect(responseJson).to.have.property('tenantId');",
                      "    pm.expect(responseJson).to.have.property('userId');",
                      "    pm.expect(responseJson).to.have.property('category');",
                      "    pm.expect(responseJson).to.have.property('inAppEnabled');",
                      "    pm.expect(responseJson).to.have.property('emailEnabled');",
                      "    pm.expect(responseJson).to.have.property('smsEnabled');",
                      "    pm.expect(responseJson).to.have.property('updatedAt');",
                      "});",
                      "",
                      "pm.test('Preference belongs to current user and tenant', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson.userId).to.equal(pm.collectionVariables.get('userId'));",
                      "    pm.expect(responseJson.tenantId).to.equal(pm.collectionVariables.get('tenantId'));",
                      "});",
                      "",
                      "pm.test('Preference values match request', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const requestBody = JSON.parse(pm.request.body.raw);",
                      "    ",
                      "    // Check that updated values match request",
                      "    if (requestBody.hasOwnProperty('inAppEnabled')) {",
                      "        pm.expect(responseJson.inAppEnabled).to.equal(requestBody.inAppEnabled);",
                      "    }",
                      "    if (requestBody.hasOwnProperty('emailEnabled')) {",
                      "        pm.expect(responseJson.emailEnabled).to.equal(requestBody.emailEnabled);",
                      "    }",
                      "    if (requestBody.hasOwnProperty('smsEnabled')) {",
                      "        pm.expect(responseJson.smsEnabled).to.equal(requestBody.smsEnabled);",
                      "    }",
                      "});",
                      "",
                      "pm.test('Updated timestamp is recent', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const updatedAt = new Date(responseJson.updatedAt);",
                      "    const now = new Date();",
                      "    const timeDiff = now - updatedAt;",
                      "    ",
                      "    // Should be updated within the last minute",
                      "    pm.expect(timeDiff).to.be.below(60000);",
                      "});",
                      "",
                      "// Log preference update results",
                      "if (pm.response.code === 200) {",
                      "    const responseJson = pm.response.json();",
                      "    const requestBody = JSON.parse(pm.request.body.raw);",
                      "    ",
                      "    console.log('‚öôÔ∏è Notification preferences updated successfully');",
                      "    console.log('üìã Updated preference details:', {",
                      "        category: responseJson.category,",
                      "        inApp: responseJson.inAppEnabled,",
                      "        email: responseJson.emailEnabled,",
                      "        sms: responseJson.smsEnabled,",
                      "        updatedAt: responseJson.updatedAt",
                      "    });",
                      "    ",
                      "    console.log('üîÑ Changes applied:', requestBody);",
                      "    console.log('‚úÖ Preference update completed');",
                      "} else if (pm.response.code === 400) {",
                      "    console.log('‚ùå Bad request - Check preference data format');",
                      "} else if (pm.response.code === 404) {",
                      "    console.log('‚ùå Category not found - Check category name');",
                      "} else if (pm.response.code === 429) {",
                      "    console.log('‚ö†Ô∏è Rate limit exceeded - Too many preference updates');",
                      "}"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for updating notification preferences",
                      "",
                      "const testCategory = pm.collectionVariables.get('testCategory');",
                      "if (!testCategory) {",
                      "    console.log('‚ö†Ô∏è Warning: testCategory not set. Please run \"Get Available Notification Categories\" first.');",
                      "    console.log('üí° Tip: The categories endpoint will capture a test category automatically');",
                      "    ",
                      "    // Set a default category for testing",
                      "    pm.collectionVariables.set('testCategory', 'system');",
                      "    console.log('üîß Set default test category: system');",
                      "}",
                      "",
                      "console.log('‚öôÔ∏è Updating preferences for category:', testCategory);",
                      "console.log('üìã Request details:', {",
                      "    category: testCategory,",
                      "    userId: pm.collectionVariables.get('userId'),",
                      "    tenantId: pm.collectionVariables.get('tenantId')",
                      "});"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Update Preferences - Disable All Email",
              "request": {
                "method": "PUT",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"emailEnabled\": false\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/notification-preferences/system",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "notification-preferences",
                    "system"
                  ]
                },
                "description": "Example of disabling email notifications for the 'system' category. This demonstrates partial preference updates where only specific channels are modified.\n\n**Scenario:** User wants to stop receiving system notification emails but keep in-app and SMS notifications\n\n**Use Case:** Privacy-focused notification management, reducing email volume"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "pm.test('Email notifications disabled for system category', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Email preference is disabled', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson.emailEnabled).to.be.false;",
                      "    pm.expect(responseJson.category).to.equal('system');",
                      "});",
                      "",
                      "console.log('üìß Email notifications disabled for system category');"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Update Preferences - Enable Only In-App",
              "request": {
                "method": "PUT",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"inAppEnabled\": true,\n  \"emailEnabled\": false,\n  \"smsEnabled\": false\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/notification-preferences/security",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "notification-preferences",
                    "security"
                  ]
                },
                "description": "Example of setting preferences to only receive in-app notifications for security category. This demonstrates comprehensive preference control.\n\n**Scenario:** User wants security notifications only within the application, no external communications\n\n**Use Case:** High-security environments, minimal external notification footprint"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "pm.test('Security preferences set to in-app only', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Only in-app notifications enabled', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson.inAppEnabled).to.be.true;",
                      "    pm.expect(responseJson.emailEnabled).to.be.false;",
                      "    pm.expect(responseJson.smsEnabled).to.be.false;",
                      "    pm.expect(responseJson.category).to.equal('security');",
                      "});",
                      "",
                      "console.log('üîí Security notifications set to in-app only');"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Update Preferences - Enable All Channels",
              "request": {
                "method": "PUT",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"inAppEnabled\": true,\n  \"emailEnabled\": true,\n  \"smsEnabled\": true\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/notification-preferences/invoice",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "notification-preferences",
                    "invoice"
                  ]
                },
                "description": "Example of enabling all notification channels for invoice category. This ensures maximum notification coverage for important financial communications.\n\n**Scenario:** User wants to receive invoice notifications through all available channels for maximum visibility\n\n**Use Case:** Critical business notifications, financial alerts, important updates"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "pm.test('All notification channels enabled for invoices', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('All channels are enabled', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson.inAppEnabled).to.be.true;",
                      "    pm.expect(responseJson.emailEnabled).to.be.true;",
                      "    pm.expect(responseJson.smsEnabled).to.be.true;",
                      "    pm.expect(responseJson.category).to.equal('invoice');",
                      "});",
                      "",
                      "console.log('üí∞ All notification channels enabled for invoice category');"
                    ]
                  }
                }
              ]
            }
          ]
        },
        {
          "name": "Broadcasting",
          "description": "Tenant-wide notification broadcasting (admin only)",
          "item": [
            {
              "name": "Broadcast to Tenant",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text",
                    "description": "Tenant identifier - required for tenant isolation"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"type\": \"INFO\",\n  \"category\": \"announcement\",\n  \"title\": \"System Maintenance Scheduled\",\n  \"message\": \"We will be performing scheduled maintenance on our systems from 2:00 AM to 4:00 AM UTC on Sunday. During this time, some services may be temporarily unavailable. We apologize for any inconvenience.\",\n  \"data\": {\n    \"maintenanceWindow\": {\n      \"start\": \"2024-01-15T02:00:00Z\",\n      \"end\": \"2024-01-15T04:00:00Z\",\n      \"timezone\": \"UTC\"\n    },\n    \"affectedServices\": [\"API\", \"Dashboard\", \"Reports\"],\n    \"actionRequired\": false,\n    \"priority\": \"high\"\n  },\n  \"priority\": \"HIGH\",\n  \"expiresAt\": \"2024-01-16T00:00:00.000Z\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/notifications/tenant-broadcast",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "notifications",
                    "tenant-broadcast"
                  ]
                },
                "description": "Broadcast a notification to all users in the current tenant. This is an admin-only endpoint with strict rate limiting.\n\n**Required Headers:**\n- `Authorization`: Bearer token (admin role required)\n- `x-tenant-id`: Tenant identifier\n- `Content-Type`: application/json\n\n**Request Body:**\n- `type`: Notification type - INFO, WARNING, SUCCESS, ERROR (required)\n- `category`: Notification category for grouping (required)\n- `title`: Notification title (required, max 255 chars)\n- `message`: Notification message content (required, max 1000 chars)\n- `data`: Additional metadata object (optional)\n- `priority`: Priority level - LOW, MEDIUM, HIGH, URGENT (optional)\n- `expiresAt`: Expiration date in ISO format (optional)\n\n**Security:**\n- Admin role validation required\n- Tenant isolation enforced\n- Rate limiting: 5 broadcasts per 5 minutes per tenant\n\n**Response:**\n- `notifications`: Array of created notification objects\n- `count`: Number of users who received the notification\n\n**Use Cases:**\n- System maintenance announcements\n- Security alerts and updates\n- Feature announcements\n- Emergency notifications\n- Company-wide communications\n- Policy updates and reminders"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for tenant broadcast",
                      "",
                      "pm.test('Tenant broadcast sent successfully', function () {",
                      "    pm.expect(pm.response.code).to.equal(201);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable for broadcast', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(5000);",
                      "});",
                      "",
                      "pm.test('Response has correct content type', function () {",
                      "    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
                      "});",
                      "",
                      "pm.test('Response contains broadcast results', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('notifications');",
                      "    pm.expect(responseJson).to.have.property('count');",
                      "    pm.expect(responseJson.notifications).to.be.an('array');",
                      "    pm.expect(responseJson.count).to.be.a('number');",
                      "});",
                      "",
                      "pm.test('Broadcast notifications have valid structure', function () {",
                      "    const responseJson = pm.response.json();",
                      "    ",
                      "    if (responseJson.notifications.length > 0) {",
                      "        const notification = responseJson.notifications[0];",
                      "        pm.expect(notification).to.have.property('id');",
                      "        pm.expect(notification).to.have.property('tenantId');",
                      "        pm.expect(notification).to.have.property('userId');",
                      "        pm.expect(notification).to.have.property('type');",
                      "        pm.expect(notification).to.have.property('category');",
                      "        pm.expect(notification).to.have.property('title');",
                      "        pm.expect(notification).to.have.property('message');",
                      "        pm.expect(notification).to.have.property('createdAt');",
                      "        ",
                      "        // Validate tenant consistency",
                      "        pm.expect(notification.tenantId).to.equal(pm.collectionVariables.get('tenantId'));",
                      "    }",
                      "});",
                      "",
                      "pm.test('Broadcast count matches notifications array', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson.count).to.equal(responseJson.notifications.length);",
                      "});",
                      "",
                      "// Log broadcast results",
                      "if (pm.response.code === 201) {",
                      "    const responseJson = pm.response.json();",
                      "    console.log('üì¢ Tenant broadcast sent successfully');",
                      "    console.log('üìä Broadcast statistics:', {",
                      "        recipientCount: responseJson.count,",
                      "        notificationsCreated: responseJson.notifications.length,",
                      "        tenantId: pm.collectionVariables.get('tenantId')",
                      "    });",
                      "    ",
                      "    if (responseJson.count === 0) {",
                      "        console.log('‚ö†Ô∏è No users found in tenant to receive broadcast');",
                      "    } else {",
                      "        console.log(`‚úÖ Broadcast delivered to ${responseJson.count} users`);",
                      "    }",
                      "} else if (pm.response.code === 403) {",
                      "    console.log('‚ùå Access denied - Admin role required for broadcasting');",
                      "} else if (pm.response.code === 429) {",
                      "    console.log('‚ö†Ô∏è Rate limit exceeded - Too many tenant broadcasts');",
                      "    console.log('üí° Tip: Wait 5 minutes between tenant broadcasts');",
                      "} else if (pm.response.code === 401) {",
                      "    console.log('‚ùå Authentication required - Check access token');",
                      "}"
                    ]
                  }
                },
                {
                  "listen": "prerequest",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Pre-request script for tenant broadcast",
                      "",
                      "// Ensure required variables are set",
                      "const tenantId = pm.collectionVariables.get('tenantId');",
                      "const accessToken = pm.collectionVariables.get('accessToken');",
                      "",
                      "if (!tenantId) {",
                      "    console.log('‚ö†Ô∏è Warning: tenantId not set. Please set tenant context.');",
                      "}",
                      "",
                      "if (!accessToken) {",
                      "    console.log('‚ö†Ô∏è Warning: accessToken not set. Please authenticate first.');",
                      "}",
                      "",
                      "// Log broadcast attempt",
                      "console.log('üì¢ Attempting tenant broadcast');",
                      "console.log('üéØ Target tenant:', tenantId);",
                      "console.log('‚ö†Ô∏è Note: This requires admin role permissions');",
                      "console.log('üö¶ Rate limit: 5 broadcasts per 5 minutes per tenant');"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Broadcast - Emergency Alert Example",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"type\": \"ERROR\",\n  \"category\": \"security\",\n  \"title\": \"üö® Security Alert: Immediate Action Required\",\n  \"message\": \"We have detected suspicious activity on your account. Please change your password immediately and review your recent login activity. If you did not authorize recent logins, contact support immediately.\",\n  \"data\": {\n    \"alertType\": \"security_breach\",\n    \"severity\": \"critical\",\n    \"actionRequired\": true,\n    \"supportContact\": \"security@company.com\",\n    \"incidentId\": \"SEC-2024-001\",\n    \"detectedAt\": \"2024-01-10T15:30:00Z\",\n    \"recommendedActions\": [\n      \"Change password immediately\",\n      \"Review login history\",\n      \"Enable two-factor authentication\",\n      \"Contact support if unauthorized access suspected\"\n    ]\n  },\n  \"priority\": \"URGENT\",\n  \"expiresAt\": \"2024-01-17T23:59:59.000Z\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/notifications/tenant-broadcast",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "notifications",
                    "tenant-broadcast"
                  ]
                },
                "description": "Example of an emergency security alert broadcast. This demonstrates how to send urgent, high-priority notifications to all tenant users.\n\n**Scenario:** Security breach detected requiring immediate user action\n\n**Key Features:**\n- URGENT priority level\n- ERROR type for critical alerts\n- Detailed action items in data object\n- Security category for proper filtering\n- Extended expiration for important alerts\n\n**Use Case:** Critical security incidents requiring immediate tenant-wide notification"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "pm.test('Emergency alert broadcast sent', function () {",
                      "    pm.expect(pm.response.code).to.equal(201);",
                      "});",
                      "",
                      "pm.test('Emergency alert has urgent priority', function () {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.notifications.length > 0) {",
                      "        const notification = responseJson.notifications[0];",
                      "        pm.expect(notification.type).to.equal('ERROR');",
                      "        pm.expect(notification.category).to.equal('security');",
                      "    }",
                      "});",
                      "",
                      "console.log('üö® Emergency security alert broadcast completed');"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Broadcast - Feature Announcement Example",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"type\": \"SUCCESS\",\n  \"category\": \"feature_announcement\",\n  \"title\": \"üéâ New Feature: Advanced Analytics Dashboard\",\n  \"message\": \"We're excited to announce the launch of our new Advanced Analytics Dashboard! Get deeper insights into your data with customizable charts, real-time metrics, and automated reports. Check it out in the Analytics section.\",\n  \"data\": {\n    \"featureName\": \"Advanced Analytics Dashboard\",\n    \"releaseDate\": \"2024-01-10\",\n    \"actionUrl\": \"/analytics/dashboard\",\n    \"features\": [\n      \"Customizable charts and graphs\",\n      \"Real-time data visualization\",\n      \"Automated report generation\",\n      \"Export capabilities\",\n      \"Mobile-responsive design\"\n    ],\n    \"documentationUrl\": \"/docs/analytics\",\n    \"videoTutorialUrl\": \"/tutorials/analytics-dashboard\",\n    \"feedbackUrl\": \"/feedback/analytics\"\n  },\n  \"priority\": \"MEDIUM\",\n  \"expiresAt\": \"2024-02-10T23:59:59.000Z\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/notifications/tenant-broadcast",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "notifications",
                    "tenant-broadcast"
                  ]
                },
                "description": "Example of a feature announcement broadcast. This demonstrates how to communicate new features and updates to all tenant users.\n\n**Scenario:** New feature launch announcement\n\n**Key Features:**\n- SUCCESS type for positive announcements\n- Detailed feature information in data object\n- Links to documentation and tutorials\n- Feedback collection URL\n- Longer expiration for feature announcements\n\n**Use Case:** Product updates, new feature rollouts, enhancement announcements"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "pm.test('Feature announcement broadcast sent', function () {",
                      "    pm.expect(pm.response.code).to.equal(201);",
                      "});",
                      "",
                      "pm.test('Feature announcement has success type', function () {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.notifications.length > 0) {",
                      "        const notification = responseJson.notifications[0];",
                      "        pm.expect(notification.type).to.equal('SUCCESS');",
                      "        pm.expect(notification.category).to.equal('feature_announcement');",
                      "    }",
                      "});",
                      "",
                      "console.log('üéâ Feature announcement broadcast completed');"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Broadcast - Rate Limit Test",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"type\": \"INFO\",\n  \"category\": \"test\",\n  \"title\": \"Rate Limit Test Notification\",\n  \"message\": \"This is a test notification to verify rate limiting on tenant broadcasts. This should fail if sent too frequently.\",\n  \"data\": {\n    \"testType\": \"rate_limit_validation\",\n    \"timestamp\": \"{{$timestamp}}\"\n  },\n  \"priority\": \"LOW\"\n}",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/notifications/tenant-broadcast",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "notifications",
                    "tenant-broadcast"
                  ]
                },
                "description": "Test request to validate rate limiting on tenant broadcasts. Run this multiple times in quick succession to test the 5 broadcasts per 5 minutes limit.\n\n**Purpose:** Validate rate limiting implementation\n\n**Expected Behavior:**\n- First 5 requests within 5 minutes: Should succeed (201)\n- 6th and subsequent requests: Should fail with 429 Too Many Requests\n- After 5 minutes: Rate limit should reset\n\n**Rate Limit:** 5 tenant broadcasts per 5 minutes\n\n**Use Case:** Testing and validating broadcast rate limiting to prevent spam"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test script for rate limit validation",
                      "",
                      "pm.test('Rate limit test completed', function () {",
                      "    // Accept both success and rate limit responses",
                      "    pm.expect(pm.response.code).to.be.oneOf([201, 429]);",
                      "});",
                      "",
                      "if (pm.response.code === 201) {",
                      "    pm.test('Broadcast sent successfully (within rate limit)', function () {",
                      "        const responseJson = pm.response.json();",
                      "        pm.expect(responseJson).to.have.property('notifications');",
                      "        pm.expect(responseJson).to.have.property('count');",
                      "    });",
                      "    console.log('‚úÖ Broadcast sent - Rate limit not exceeded');",
                      "} else if (pm.response.code === 429) {",
                      "    pm.test('Rate limit properly enforced', function () {",
                      "        const responseJson = pm.response.json();",
                      "        pm.expect(responseJson).to.have.property('message');",
                      "    });",
                      "    console.log('üö¶ Rate limit exceeded - This is expected behavior');",
                      "    console.log('üí° Wait 5 minutes before attempting more broadcasts');",
                      "}",
                      "",
                      "// Log rate limiting information",
                      "const headers = pm.response.headers;",
                      "const rateLimitRemaining = headers.get('X-RateLimit-Remaining');",
                      "const rateLimitReset = headers.get('X-RateLimit-Reset');",
                      "",
                      "if (rateLimitRemaining) {",
                      "    console.log('üö¶ Rate limit remaining:', rateLimitRemaining);",
                      "}",
                      "",
                      "if (rateLimitReset) {",
                      "    console.log('üïí Rate limit resets at:', new Date(parseInt(rateLimitReset) * 1000).toISOString());",
                      "}"
                    ]
                  }
                }
              ]
            }
          ]
        },
        {
          "name": "Privacy Controls",
          "description": "Notification privacy and visibility controls",
          "item": []
        }
      ]
    },
    {
      "name": "üìä System Monitoring",
      "description": "System health monitoring and alerting (admin access required)",
      "item": [
        {
          "name": "Queue Monitoring",
          "description": "Monitor notification queues and processing statistics",
          "item": [
            {
              "name": "Get Queue Statistics",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  },
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/monitoring/queue-stats",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "monitoring",
                    "queue-stats"
                  ]
                },
                "description": "Retrieve comprehensive statistics for notification queues including email and SMS processing metrics.\n\n**Authentication:** Required (Admin role only)\n**Authorization:** Admin role required\n**Rate Limiting:** Standard admin rate limits apply\n\n**Response Format:**\n```json\n{\n  \"email\": {\n    \"depth\": 0,\n    \"lag\": 0,\n    \"processed\": 1250,\n    \"failed\": 3,\n    \"active\": 2,\n    \"waiting\": 0,\n    \"delayed\": 0,\n    \"completed\": 1247,\n    \"paused\": false\n  },\n  \"sms\": {\n    \"depth\": 0,\n    \"lag\": 0,\n    \"processed\": 856,\n    \"failed\": 1,\n    \"active\": 0,\n    \"waiting\": 0,\n    \"delayed\": 0,\n    \"completed\": 855,\n    \"paused\": false\n  },\n  \"timestamp\": \"2024-01-15T10:30:00.000Z\",\n  \"uptime\": 86400\n}\n```\n\n**Queue Metrics Explained:**\n- `depth`: Current number of jobs in queue\n- `lag`: Processing delay in milliseconds\n- `processed`: Total jobs processed since startup\n- `failed`: Number of failed jobs\n- `active`: Currently processing jobs\n- `waiting`: Jobs waiting to be processed\n- `delayed`: Jobs scheduled for future processing\n- `completed`: Successfully completed jobs\n- `paused`: Whether queue processing is paused\n\n**Use Cases:**\n- Monitor queue performance and health\n- Identify processing bottlenecks\n- Track notification delivery metrics\n- Capacity planning and scaling decisions\n- Troubleshoot notification delays\n\n**Error Scenarios:**\n- 401 Unauthorized: Missing or invalid authentication\n- 403 Forbidden: Insufficient permissions (admin role required)\n- 500 Internal Server Error: Queue monitoring service issues"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Queue Statistics Monitoring Test Suite",
                      "",
                      "pm.test('Queue statistics endpoint responds successfully', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable for monitoring', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});",
                      "",
                      "pm.test('Response has valid JSON structure', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('object');",
                      "    pm.expect(responseJson).to.have.property('email');",
                      "    pm.expect(responseJson).to.have.property('sms');",
                      "    pm.expect(responseJson).to.have.property('timestamp');",
                      "});",
                      "",
                      "pm.test('Email queue statistics are complete', function () {",
                      "    const emailStats = pm.response.json().email;",
                      "    const requiredFields = ['depth', 'lag', 'processed', 'failed', 'active', 'waiting', 'delayed', 'completed', 'paused'];",
                      "    ",
                      "    requiredFields.forEach(field => {",
                      "        pm.expect(emailStats).to.have.property(field);",
                      "    });",
                      "});",
                      "",
                      "pm.test('SMS queue statistics are complete', function () {",
                      "    const smsStats = pm.response.json().sms;",
                      "    const requiredFields = ['depth', 'lag', 'processed', 'failed', 'active', 'waiting', 'delayed', 'completed', 'paused'];",
                      "    ",
                      "    requiredFields.forEach(field => {",
                      "        pm.expect(smsStats).to.have.property(field);",
                      "    });",
                      "});",
                      "",
                      "pm.test('Queue metrics have valid data types', function () {",
                      "    const responseJson = pm.response.json();",
                      "    ",
                      "    ['email', 'sms'].forEach(queueType => {",
                      "        const stats = responseJson[queueType];",
                      "        pm.expect(stats.depth).to.be.a('number');",
                      "        pm.expect(stats.lag).to.be.a('number');",
                      "        pm.expect(stats.processed).to.be.a('number');",
                      "        pm.expect(stats.failed).to.be.a('number');",
                      "        pm.expect(stats.active).to.be.a('number');",
                      "        pm.expect(stats.waiting).to.be.a('number');",
                      "        pm.expect(stats.delayed).to.be.a('number');",
                      "        pm.expect(stats.completed).to.be.a('number');",
                      "        pm.expect(stats.paused).to.be.a('boolean');",
                      "    });",
                      "});",
                      "",
                      "// Detailed queue analysis and alerting",
                      "const responseJson = pm.response.json();",
                      "",
                      "console.log('üìä === QUEUE MONITORING REPORT ===');",
                      "console.log('üìä Timestamp:', responseJson.timestamp);",
                      "console.log('üìä System Uptime:', responseJson.uptime ? (responseJson.uptime / 3600).toFixed(2) + ' hours' : 'N/A');",
                      "",
                      "// Email Queue Analysis",
                      "const emailStats = responseJson.email;",
                      "console.log('üìß === EMAIL QUEUE STATISTICS ===');",
                      "console.log('  Queue Depth:', emailStats.depth);",
                      "console.log('  Processing Lag:', emailStats.lag + 'ms');",
                      "console.log('  Total Processed:', emailStats.processed);",
                      "console.log('  Success Rate:', ((emailStats.completed / emailStats.processed) * 100).toFixed(2) + '%');",
                      "console.log('  Failed Jobs:', emailStats.failed);",
                      "console.log('  Currently Active:', emailStats.active);",
                      "console.log('  Waiting Jobs:', emailStats.waiting);",
                      "console.log('  Delayed Jobs:', emailStats.delayed);",
                      "console.log('  Queue Status:', emailStats.paused ? '‚è∏Ô∏è PAUSED' : '‚ñ∂Ô∏è RUNNING');",
                      "",
                      "// SMS Queue Analysis",
                      "const smsStats = responseJson.sms;",
                      "console.log('üì± === SMS QUEUE STATISTICS ===');",
                      "console.log('  Queue Depth:', smsStats.depth);",
                      "console.log('  Processing Lag:', smsStats.lag + 'ms');",
                      "console.log('  Total Processed:', smsStats.processed);",
                      "console.log('  Success Rate:', ((smsStats.completed / smsStats.processed) * 100).toFixed(2) + '%');",
                      "console.log('  Failed Jobs:', smsStats.failed);",
                      "console.log('  Currently Active:', smsStats.active);",
                      "console.log('  Waiting Jobs:', smsStats.waiting);",
                      "console.log('  Delayed Jobs:', smsStats.delayed);",
                      "console.log('  Queue Status:', smsStats.paused ? '‚è∏Ô∏è PAUSED' : '‚ñ∂Ô∏è RUNNING');",
                      "",
                      "// Health and Performance Alerts",
                      "console.log('üö® === QUEUE HEALTH ANALYSIS ===');",
                      "",
                      "// Check for high queue depth",
                      "if (emailStats.depth > 100 || smsStats.depth > 100) {",
                      "    console.log('‚ö†Ô∏è HIGH QUEUE DEPTH ALERT');",
                      "    console.log('  Email queue depth:', emailStats.depth);",
                      "    console.log('  SMS queue depth:', smsStats.depth);",
                      "    console.log('üí° Consider scaling workers or investigating processing delays');",
                      "}",
                      "",
                      "// Check for high processing lag",
                      "if (emailStats.lag > 5000 || smsStats.lag > 5000) {",
                      "    console.log('‚ö†Ô∏è HIGH PROCESSING LAG ALERT');",
                      "    console.log('  Email lag:', emailStats.lag + 'ms');",
                      "    console.log('  SMS lag:', smsStats.lag + 'ms');",
                      "    console.log('üí° Investigate worker performance and resource allocation');",
                      "}",
                      "",
                      "// Check for high failure rates",
                      "const emailFailureRate = (emailStats.failed / emailStats.processed) * 100;",
                      "const smsFailureRate = (smsStats.failed / smsStats.processed) * 100;",
                      "",
                      "if (emailFailureRate > 5 || smsFailureRate > 5) {",
                      "    console.log('‚ö†Ô∏è HIGH FAILURE RATE ALERT');",
                      "    console.log('  Email failure rate:', emailFailureRate.toFixed(2) + '%');",
                      "    console.log('  SMS failure rate:', smsFailureRate.toFixed(2) + '%');",
                      "    console.log('üí° Check provider configurations and error logs');",
                      "}",
                      "",
                      "// Check for paused queues",
                      "if (emailStats.paused || smsStats.paused) {",
                      "    console.log('üö® PAUSED QUEUE ALERT');",
                      "    console.log('  Email queue paused:', emailStats.paused);",
                      "    console.log('  SMS queue paused:', smsStats.paused);",
                      "    console.log('üí° Queues may be paused for maintenance or due to errors');",
                      "}",
                      "",
                      "// Positive health indicators",
                      "if (emailStats.depth < 10 && smsStats.depth < 10 && emailStats.lag < 1000 && smsStats.lag < 1000) {",
                      "    console.log('‚úÖ QUEUE HEALTH: EXCELLENT');",
                      "    console.log('  All queues are processing efficiently with low latency');",
                      "}",
                      "",
                      "// Performance summary",
                      "const totalProcessed = emailStats.processed + smsStats.processed;",
                      "const totalFailed = emailStats.failed + smsStats.failed;",
                      "const overallSuccessRate = ((totalProcessed - totalFailed) / totalProcessed) * 100;",
                      "",
                      "console.log('üìä === OVERALL PERFORMANCE SUMMARY ===');",
                      "console.log('  Total Notifications Processed:', totalProcessed);",
                      "console.log('  Overall Success Rate:', overallSuccessRate.toFixed(2) + '%');",
                      "console.log('  System Performance:', overallSuccessRate > 95 ? 'üöÄ EXCELLENT' : overallSuccessRate > 90 ? '‚úÖ GOOD' : '‚ö†Ô∏è NEEDS ATTENTION');",
                      "",
                      "console.log('üìä === END QUEUE MONITORING REPORT ===');"
                    ]
                  }
                }
              ]
            }
          ]
        },
        {
          "name": "Alert Management",
          "description": "Configure and manage system alerts",
          "item": [
            {
              "name": "Get Alert Configuration",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  },
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/monitoring/alert-config",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "monitoring",
                    "alert-config"
                  ]
                },
                "description": "Retrieve the current alert configuration including thresholds, notification settings, and alert rules.\n\n**Authentication:** Required (Admin role only)\n**Authorization:** Admin role required\n**Rate Limiting:** Standard admin rate limits apply\n\n**Response Format:**\n```json\n{\n  \"queueDepthThreshold\": 100,\n  \"processingLagThreshold\": 5000,\n  \"failureRateThreshold\": 5,\n  \"alertCooldownMinutes\": 15,\n  \"notificationChannels\": {\n    \"email\": {\n      \"enabled\": true,\n      \"recipients\": [\"admin@example.com\", \"ops@example.com\"]\n    },\n    \"webhook\": {\n      \"enabled\": true,\n      \"url\": \"https://hooks.slack.com/services/...\"\n    }\n  },\n  \"alertRules\": [\n    {\n      \"name\": \"High Queue Depth\",\n      \"condition\": \"queue_depth > 100\",\n      \"severity\": \"warning\",\n      \"enabled\": true\n    },\n    {\n      \"name\": \"Processing Lag\",\n      \"condition\": \"processing_lag > 5000\",\n      \"severity\": \"critical\",\n      \"enabled\": true\n    }\n  ],\n  \"lastUpdated\": \"2024-01-15T10:30:00.000Z\"\n}\n```\n\n**Configuration Parameters:**\n- `queueDepthThreshold`: Maximum queue depth before alert\n- `processingLagThreshold`: Maximum processing lag in milliseconds\n- `failureRateThreshold`: Maximum failure rate percentage\n- `alertCooldownMinutes`: Minimum time between duplicate alerts\n- `notificationChannels`: Alert delivery configuration\n- `alertRules`: Custom alert conditions and severity levels\n\n**Use Cases:**\n- Review current alert settings\n- Validate alert configuration\n- Audit alert rule changes\n- Troubleshoot alert delivery issues\n- Monitor alert system health\n\n**Error Scenarios:**\n- 401 Unauthorized: Missing or invalid authentication\n- 403 Forbidden: Insufficient permissions (admin role required)\n- 500 Internal Server Error: Alert configuration service issues"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Alert Configuration Test Suite",
                      "",
                      "pm.test('Alert configuration endpoint responds successfully', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(2000);",
                      "});",
                      "",
                      "pm.test('Response has valid alert configuration structure', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('object');",
                      "    pm.expect(responseJson).to.have.property('queueDepthThreshold');",
                      "    pm.expect(responseJson).to.have.property('processingLagThreshold');",
                      "    pm.expect(responseJson).to.have.property('failureRateThreshold');",
                      "    pm.expect(responseJson).to.have.property('alertCooldownMinutes');",
                      "});",
                      "",
                      "pm.test('Threshold values are valid numbers', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson.queueDepthThreshold).to.be.a('number');",
                      "    pm.expect(responseJson.processingLagThreshold).to.be.a('number');",
                      "    pm.expect(responseJson.failureRateThreshold).to.be.a('number');",
                      "    pm.expect(responseJson.alertCooldownMinutes).to.be.a('number');",
                      "});",
                      "",
                      "pm.test('Notification channels configuration is present', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('notificationChannels');",
                      "    pm.expect(responseJson.notificationChannels).to.be.an('object');",
                      "});",
                      "",
                      "pm.test('Alert rules are properly configured', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('alertRules');",
                      "    pm.expect(responseJson.alertRules).to.be.an('array');",
                      "    ",
                      "    if (responseJson.alertRules.length > 0) {",
                      "        const rule = responseJson.alertRules[0];",
                      "        pm.expect(rule).to.have.property('name');",
                      "        pm.expect(rule).to.have.property('condition');",
                      "        pm.expect(rule).to.have.property('severity');",
                      "        pm.expect(rule).to.have.property('enabled');",
                      "    }",
                      "});",
                      "",
                      "// Detailed configuration analysis",
                      "const responseJson = pm.response.json();",
                      "",
                      "console.log('üö® === ALERT CONFIGURATION REPORT ===');",
                      "console.log('üìä Last Updated:', responseJson.lastUpdated);",
                      "",
                      "console.log('‚öôÔ∏è === THRESHOLD CONFIGURATION ===');",
                      "console.log('  Queue Depth Threshold:', responseJson.queueDepthThreshold);",
                      "console.log('  Processing Lag Threshold:', responseJson.processingLagThreshold + 'ms');",
                      "console.log('  Failure Rate Threshold:', responseJson.failureRateThreshold + '%');",
                      "console.log('  Alert Cooldown:', responseJson.alertCooldownMinutes + ' minutes');",
                      "",
                      "// Notification channels analysis",
                      "if (responseJson.notificationChannels) {",
                      "    console.log('üì¢ === NOTIFICATION CHANNELS ===');",
                      "    ",
                      "    if (responseJson.notificationChannels.email) {",
                      "        const email = responseJson.notificationChannels.email;",
                      "        console.log('  Email Notifications:', email.enabled ? '‚úÖ ENABLED' : '‚ùå DISABLED');",
                      "        if (email.enabled && email.recipients) {",
                      "            console.log('  Email Recipients:', email.recipients.length + ' configured');",
                      "        }",
                      "    }",
                      "    ",
                      "    if (responseJson.notificationChannels.webhook) {",
                      "        const webhook = responseJson.notificationChannels.webhook;",
                      "        console.log('  Webhook Notifications:', webhook.enabled ? '‚úÖ ENABLED' : '‚ùå DISABLED');",
                      "        if (webhook.enabled && webhook.url) {",
                      "            console.log('  Webhook URL:', webhook.url.substring(0, 50) + '...');",
                      "        }",
                      "    }",
                      "}",
                      "",
                      "// Alert rules analysis",
                      "if (responseJson.alertRules && responseJson.alertRules.length > 0) {",
                      "    console.log('üìã === ALERT RULES (' + responseJson.alertRules.length + ' configured) ===');",
                      "    ",
                      "    responseJson.alertRules.forEach((rule, index) => {",
                      "        console.log(`  Rule ${index + 1}: ${rule.name}`);",
                      "        console.log(`    Condition: ${rule.condition}`);",
                      "        console.log(`    Severity: ${rule.severity.toUpperCase()}`);",
                      "        console.log(`    Status: ${rule.enabled ? '‚úÖ ENABLED' : '‚ùå DISABLED'}`);",
                      "    });",
                      "} else {",
                      "    console.log('üìã === ALERT RULES ===');",
                      "    console.log('  ‚ö†Ô∏è No alert rules configured');",
                      "}",
                      "",
                      "// Configuration validation and recommendations",
                      "console.log('üí° === CONFIGURATION ANALYSIS ===');",
                      "",
                      "// Check threshold reasonableness",
                      "if (responseJson.queueDepthThreshold > 1000) {",
                      "    console.log('‚ö†Ô∏è Queue depth threshold seems high (> 1000)');",
                      "} else if (responseJson.queueDepthThreshold < 10) {",
                      "    console.log('‚ö†Ô∏è Queue depth threshold seems low (< 10)');",
                      "} else {",
                      "    console.log('‚úÖ Queue depth threshold is reasonable');",
                      "}",
                      "",
                      "if (responseJson.processingLagThreshold > 30000) {",
                      "    console.log('‚ö†Ô∏è Processing lag threshold seems high (> 30s)');",
                      "} else if (responseJson.processingLagThreshold < 1000) {",
                      "    console.log('‚ö†Ô∏è Processing lag threshold seems low (< 1s)');",
                      "} else {",
                      "    console.log('‚úÖ Processing lag threshold is reasonable');",
                      "}",
                      "",
                      "if (responseJson.failureRateThreshold > 20) {",
                      "    console.log('‚ö†Ô∏è Failure rate threshold seems high (> 20%)');",
                      "} else if (responseJson.failureRateThreshold < 1) {",
                      "    console.log('‚ö†Ô∏è Failure rate threshold seems low (< 1%)');",
                      "} else {",
                      "    console.log('‚úÖ Failure rate threshold is reasonable');",
                      "}",
                      "",
                      "// Check notification configuration",
                      "let notificationConfigured = false;",
                      "if (responseJson.notificationChannels) {",
                      "    if (responseJson.notificationChannels.email && responseJson.notificationChannels.email.enabled) {",
                      "        notificationConfigured = true;",
                      "    }",
                      "    if (responseJson.notificationChannels.webhook && responseJson.notificationChannels.webhook.enabled) {",
                      "        notificationConfigured = true;",
                      "    }",
                      "}",
                      "",
                      "if (notificationConfigured) {",
                      "    console.log('‚úÖ Alert notifications are properly configured');",
                      "} else {",
                      "    console.log('‚ö†Ô∏è No alert notification channels are enabled');",
                      "    console.log('üí° Consider enabling email or webhook notifications');",
                      "}",
                      "",
                      "// Overall configuration health",
                      "const hasRules = responseJson.alertRules && responseJson.alertRules.length > 0;",
                      "const hasEnabledRules = hasRules && responseJson.alertRules.some(rule => rule.enabled);",
                      "",
                      "if (hasEnabledRules && notificationConfigured) {",
                      "    console.log('üéâ Alert system is fully configured and operational');",
                      "} else {",
                      "    console.log('‚ö†Ô∏è Alert system configuration needs attention');",
                      "    if (!hasEnabledRules) console.log('üí° Enable alert rules for monitoring');",
                      "    if (!notificationConfigured) console.log('üí° Configure notification channels');",
                      "}",
                      "",
                      "console.log('üö® === END ALERT CONFIGURATION REPORT ===');"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Get Alert History",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  },
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/monitoring/alert-history",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "monitoring",
                    "alert-history"
                  ]
                },
                "description": "Retrieve the history of triggered alerts including timestamps, severity levels, and resolution status.\n\n**Authentication:** Required (Admin role only)\n**Authorization:** Admin role required\n**Rate Limiting:** Standard admin rate limits apply\n\n**Response Format:**\n```json\n{\n  \"alerts\": [\n    {\n      \"id\": \"alert-123\",\n      \"ruleName\": \"High Queue Depth\",\n      \"severity\": \"warning\",\n      \"message\": \"Email queue depth exceeded threshold: 150 > 100\",\n      \"triggeredAt\": \"2024-01-15T10:25:00.000Z\",\n      \"resolvedAt\": \"2024-01-15T10:30:00.000Z\",\n      \"status\": \"resolved\",\n      \"metadata\": {\n        \"queueType\": \"email\",\n        \"currentDepth\": 150,\n        \"threshold\": 100\n      }\n    }\n  ],\n  \"pagination\": {\n    \"total\": 25,\n    \"page\": 1,\n    \"limit\": 10,\n    \"totalPages\": 3\n  },\n  \"summary\": {\n    \"totalAlerts\": 25,\n    \"activeAlerts\": 2,\n    \"resolvedAlerts\": 23,\n    \"criticalAlerts\": 3,\n    \"warningAlerts\": 22\n  }\n}\n```\n\n**Alert Status Values:**\n- `active`: Alert is currently active\n- `resolved`: Alert condition has been resolved\n- `acknowledged`: Alert has been acknowledged by admin\n- `suppressed`: Alert is temporarily suppressed\n\n**Severity Levels:**\n- `critical`: Requires immediate attention\n- `warning`: Needs monitoring but not critical\n- `info`: Informational alerts\n\n**Use Cases:**\n- Review recent alert activity\n- Analyze alert patterns and trends\n- Audit alert response times\n- Identify recurring issues\n- Monitor alert system effectiveness\n\n**Query Parameters (Optional):**\n- `?severity=critical` - Filter by severity level\n- `?status=active` - Filter by alert status\n- `?limit=20` - Number of alerts per page\n- `?page=2` - Page number for pagination\n\n**Error Scenarios:**\n- 401 Unauthorized: Missing or invalid authentication\n- 403 Forbidden: Insufficient permissions (admin role required)\n- 500 Internal Server Error: Alert history service issues"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Alert History Test Suite",
                      "",
                      "pm.test('Alert history endpoint responds successfully', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                      "});",
                      "",
                      "pm.test('Response has valid alert history structure', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('object');",
                      "    pm.expect(responseJson).to.have.property('alerts');",
                      "    pm.expect(responseJson).to.have.property('summary');",
                      "    pm.expect(responseJson.alerts).to.be.an('array');",
                      "});",
                      "",
                      "pm.test('Alert summary contains required metrics', function () {",
                      "    const summary = pm.response.json().summary;",
                      "    pm.expect(summary).to.have.property('totalAlerts');",
                      "    pm.expect(summary).to.have.property('activeAlerts');",
                      "    pm.expect(summary).to.have.property('resolvedAlerts');",
                      "    pm.expect(summary).to.have.property('criticalAlerts');",
                      "    pm.expect(summary).to.have.property('warningAlerts');",
                      "});",
                      "",
                      "pm.test('Alert entries have required fields', function () {",
                      "    const alerts = pm.response.json().alerts;",
                      "    ",
                      "    if (alerts.length > 0) {",
                      "        const alert = alerts[0];",
                      "        pm.expect(alert).to.have.property('id');",
                      "        pm.expect(alert).to.have.property('ruleName');",
                      "        pm.expect(alert).to.have.property('severity');",
                      "        pm.expect(alert).to.have.property('message');",
                      "        pm.expect(alert).to.have.property('triggeredAt');",
                      "        pm.expect(alert).to.have.property('status');",
                      "    }",
                      "});",
                      "",
                      "pm.test('Pagination information is present', function () {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.pagination) {",
                      "        pm.expect(responseJson.pagination).to.have.property('total');",
                      "        pm.expect(responseJson.pagination).to.have.property('page');",
                      "        pm.expect(responseJson.pagination).to.have.property('limit');",
                      "    }",
                      "});",
                      "",
                      "// Detailed alert history analysis",
                      "const responseJson = pm.response.json();",
                      "",
                      "console.log('üìö === ALERT HISTORY REPORT ===');",
                      "",
                      "// Summary statistics",
                      "const summary = responseJson.summary;",
                      "console.log('üìä === ALERT SUMMARY STATISTICS ===');",
                      "console.log('  Total Alerts:', summary.totalAlerts);",
                      "console.log('  Active Alerts:', summary.activeAlerts);",
                      "console.log('  Resolved Alerts:', summary.resolvedAlerts);",
                      "console.log('  Critical Alerts:', summary.criticalAlerts);",
                      "console.log('  Warning Alerts:', summary.warningAlerts);",
                      "",
                      "// Calculate resolution rate",
                      "const resolutionRate = summary.totalAlerts > 0 ? (summary.resolvedAlerts / summary.totalAlerts * 100).toFixed(2) : 0;",
                      "console.log('  Resolution Rate:', resolutionRate + '%');",
                      "",
                      "// Alert severity distribution",
                      "const criticalPercentage = summary.totalAlerts > 0 ? (summary.criticalAlerts / summary.totalAlerts * 100).toFixed(1) : 0;",
                      "const warningPercentage = summary.totalAlerts > 0 ? (summary.warningAlerts / summary.totalAlerts * 100).toFixed(1) : 0;",
                      "console.log('  Critical Alert Rate:', criticalPercentage + '%');",
                      "console.log('  Warning Alert Rate:', warningPercentage + '%');",
                      "",
                      "// Recent alerts analysis",
                      "const alerts = responseJson.alerts;",
                      "console.log('üìã === RECENT ALERTS (' + alerts.length + ' shown) ===');",
                      "",
                      "if (alerts.length > 0) {",
                      "    alerts.slice(0, 5).forEach((alert, index) => {",
                      "        console.log(`  Alert ${index + 1}: ${alert.ruleName}`);",
                      "        console.log(`    Severity: ${alert.severity.toUpperCase()}`);",
                      "        console.log(`    Status: ${alert.status.toUpperCase()}`);",
                      "        console.log(`    Triggered: ${alert.triggeredAt}`);",
                      "        if (alert.resolvedAt) {",
                      "            const duration = new Date(alert.resolvedAt) - new Date(alert.triggeredAt);",
                      "            console.log(`    Duration: ${Math.round(duration / 60000)} minutes`);",
                      "        }",
                      "        console.log(`    Message: ${alert.message}`);",
                      "        console.log('');",
                      "    });",
                      "} else {",
                      "    console.log('  No recent alerts found');",
                      "}",
                      "",
                      "// Alert pattern analysis",
                      "console.log('üîç === ALERT PATTERN ANALYSIS ===');",
                      "",
                      "// Active alerts concern",
                      "if (summary.activeAlerts > 0) {",
                      "    console.log('üö® ACTIVE ALERTS DETECTED');",
                      "    console.log('  Count:', summary.activeAlerts);",
                      "    console.log('üí° Review active alerts and take corrective action');",
                      "} else {",
                      "    console.log('‚úÖ No active alerts - system is stable');",
                      "}",
                      "",
                      "// Critical alert frequency",
                      "if (summary.criticalAlerts > summary.totalAlerts * 0.1) {",
                      "    console.log('‚ö†Ô∏è HIGH CRITICAL ALERT FREQUENCY');",
                      "    console.log('  Critical alerts represent ' + criticalPercentage + '% of all alerts');",
                      "    console.log('üí° Consider reviewing alert thresholds or system capacity');",
                      "} else if (summary.criticalAlerts === 0) {",
                      "    console.log('‚úÖ No critical alerts - excellent system stability');",
                      "} else {",
                      "    console.log('‚úÖ Critical alert frequency is within acceptable range');",
                      "}",
                      "",
                      "// Resolution effectiveness",
                      "if (parseFloat(resolutionRate) > 90) {",
                      "    console.log('‚úÖ EXCELLENT alert resolution rate (' + resolutionRate + '%)');",
                      "} else if (parseFloat(resolutionRate) > 75) {",
                      "    console.log('‚úÖ Good alert resolution rate (' + resolutionRate + '%)');",
                      "} else {",
                      "    console.log('‚ö†Ô∏è Alert resolution rate needs improvement (' + resolutionRate + '%)');",
                      "    console.log('üí° Review alert handling processes and automation');",
                      "}",
                      "",
                      "// Recent alert trends",
                      "if (alerts.length > 0) {",
                      "    const recentAlerts = alerts.filter(alert => {",
                      "        const alertTime = new Date(alert.triggeredAt);",
                      "        const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);",
                      "        return alertTime > oneDayAgo;",
                      "    });",
                      "    ",
                      "    console.log('üìà Recent Activity (24h):', recentAlerts.length + ' alerts');",
                      "    ",
                      "    if (recentAlerts.length > 10) {",
                      "        console.log('‚ö†Ô∏è High alert volume in last 24 hours');",
                      "        console.log('üí° Investigate potential system issues or alert sensitivity');",
                      "    } else if (recentAlerts.length === 0) {",
                      "        console.log('‚úÖ No alerts in last 24 hours - system is stable');",
                      "    }",
                      "}",
                      "",
                      "// Pagination info",
                      "if (responseJson.pagination) {",
                      "    const pagination = responseJson.pagination;",
                      "    console.log('üìÑ === PAGINATION INFO ===');",
                      "    console.log('  Current Page:', pagination.page);",
                      "    console.log('  Total Pages:', pagination.totalPages);",
                      "    console.log('  Items per Page:', pagination.limit);",
                      "    console.log('  Total Items:', pagination.total);",
                      "}",
                      "",
                      "console.log('üìö === END ALERT HISTORY REPORT ===');"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Trigger Test Alert",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  },
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/monitoring/test-alert",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "monitoring",
                    "test-alert"
                  ]
                },
                "description": "Trigger a test alert to validate the alert system configuration and notification delivery.\n\n**Authentication:** Required (Admin role only)\n**Authorization:** Admin role required\n**Rate Limiting:** Limited to prevent spam (max 5 test alerts per hour)\n\n**Request Body:** Empty (no body required)\n\n**Response Format:**\n```json\n{\n  \"message\": \"Test alert triggered successfully\",\n  \"alertId\": \"test-alert-456\",\n  \"triggeredAt\": \"2024-01-15T10:30:00.000Z\",\n  \"notificationsSent\": {\n    \"email\": {\n      \"sent\": true,\n      \"recipients\": 2,\n      \"deliveryTime\": \"150ms\"\n    },\n    \"webhook\": {\n      \"sent\": true,\n      \"url\": \"https://hooks.slack.com/...\",\n      \"deliveryTime\": \"89ms\"\n    }\n  },\n  \"testDetails\": {\n    \"severity\": \"info\",\n    \"message\": \"This is a test alert to validate system configuration\",\n    \"ruleName\": \"Test Alert Rule\"\n  }\n}\n```\n\n**Test Alert Behavior:**\n- Creates a test alert with 'info' severity\n- Triggers all configured notification channels\n- Does not affect production alert thresholds\n- Automatically resolves after 5 minutes\n- Includes delivery confirmation for each channel\n\n**Use Cases:**\n- Validate alert system configuration\n- Test notification channel delivery\n- Verify alert routing and formatting\n- Troubleshoot alert delivery issues\n- Validate alert system after configuration changes\n\n**Validation Checks:**\n- Alert configuration is properly loaded\n- Notification channels are accessible\n- Alert formatting and routing works correctly\n- Delivery times are within acceptable ranges\n\n**Error Scenarios:**\n- 401 Unauthorized: Missing or invalid authentication\n- 403 Forbidden: Insufficient permissions (admin role required)\n- 429 Too Many Requests: Test alert rate limit exceeded\n- 500 Internal Server Error: Alert system configuration issues\n- 503 Service Unavailable: Notification channels unavailable"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Test Alert Trigger Test Suite",
                      "",
                      "pm.test('Test alert triggered successfully', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable for alert trigger', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(5000);",
                      "});",
                      "",
                      "pm.test('Response has valid test alert structure', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('object');",
                      "    pm.expect(responseJson).to.have.property('message');",
                      "    pm.expect(responseJson).to.have.property('alertId');",
                      "    pm.expect(responseJson).to.have.property('triggeredAt');",
                      "});",
                      "",
                      "pm.test('Alert ID is generated', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson.alertId).to.be.a('string');",
                      "    pm.expect(responseJson.alertId.length).to.be.greaterThan(0);",
                      "});",
                      "",
                      "pm.test('Triggered timestamp is valid', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const timestamp = new Date(responseJson.triggeredAt);",
                      "    pm.expect(timestamp.toISOString()).to.equal(responseJson.triggeredAt);",
                      "});",
                      "",
                      "pm.test('Notification delivery information is present', function () {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.notificationsSent) {",
                      "        pm.expect(responseJson.notificationsSent).to.be.an('object');",
                      "    }",
                      "});",
                      "",
                      "// Detailed test alert analysis",
                      "const responseJson = pm.response.json();",
                      "",
                      "console.log('üß™ === TEST ALERT EXECUTION REPORT ===');",
                      "console.log('üìä Alert ID:', responseJson.alertId);",
                      "console.log('üìä Triggered At:', responseJson.triggeredAt);",
                      "console.log('üìä Response Time:', pm.response.responseTime + 'ms');",
                      "",
                      "// Test details analysis",
                      "if (responseJson.testDetails) {",
                      "    console.log('üîç === TEST ALERT DETAILS ===');",
                      "    console.log('  Severity:', responseJson.testDetails.severity.toUpperCase());",
                      "    console.log('  Rule Name:', responseJson.testDetails.ruleName);",
                      "    console.log('  Message:', responseJson.testDetails.message);",
                      "}",
                      "",
                      "// Notification delivery analysis",
                      "if (responseJson.notificationsSent) {",
                      "    console.log('üì¢ === NOTIFICATION DELIVERY RESULTS ===');",
                      "    ",
                      "    const notifications = responseJson.notificationsSent;",
                      "    let totalChannels = 0;",
                      "    let successfulChannels = 0;",
                      "    let totalDeliveryTime = 0;",
                      "    ",
                      "    // Email notifications",
                      "    if (notifications.email) {",
                      "        totalChannels++;",
                      "        console.log('  üìß Email Notifications:');",
                      "        console.log('    Status:', notifications.email.sent ? '‚úÖ SENT' : '‚ùå FAILED');",
                      "        if (notifications.email.sent) {",
                      "            successfulChannels++;",
                      "            console.log('    Recipients:', notifications.email.recipients);",
                      "            console.log('    Delivery Time:', notifications.email.deliveryTime);",
                      "            totalDeliveryTime += parseInt(notifications.email.deliveryTime);",
                      "        }",
                      "    }",
                      "    ",
                      "    // Webhook notifications",
                      "    if (notifications.webhook) {",
                      "        totalChannels++;",
                      "        console.log('  üîó Webhook Notifications:');",
                      "        console.log('    Status:', notifications.webhook.sent ? '‚úÖ SENT' : '‚ùå FAILED');",
                      "        if (notifications.webhook.sent) {",
                      "            successfulChannels++;",
                      "            console.log('    URL:', notifications.webhook.url.substring(0, 50) + '...');",
                      "            console.log('    Delivery Time:', notifications.webhook.deliveryTime);",
                      "            totalDeliveryTime += parseInt(notifications.webhook.deliveryTime);",
                      "        }",
                      "    }",
                      "    ",
                      "    // SMS notifications (if present)",
                      "    if (notifications.sms) {",
                      "        totalChannels++;",
                      "        console.log('  üì± SMS Notifications:');",
                      "        console.log('    Status:', notifications.sms.sent ? '‚úÖ SENT' : '‚ùå FAILED');",
                      "        if (notifications.sms.sent) {",
                      "            successfulChannels++;",
                      "            console.log('    Recipients:', notifications.sms.recipients);",
                      "            console.log('    Delivery Time:', notifications.sms.deliveryTime);",
                      "            totalDeliveryTime += parseInt(notifications.sms.deliveryTime);",
                      "        }",
                      "    }",
                      "    ",
                      "    // Delivery summary",
                      "    console.log('üìä === DELIVERY SUMMARY ===');",
                      "    console.log('  Total Channels:', totalChannels);",
                      "    console.log('  Successful Deliveries:', successfulChannels);",
                      "    console.log('  Success Rate:', totalChannels > 0 ? ((successfulChannels / totalChannels) * 100).toFixed(1) + '%' : 'N/A');",
                      "    if (successfulChannels > 0) {",
                      "        console.log('  Average Delivery Time:', Math.round(totalDeliveryTime / successfulChannels) + 'ms');",
                      "    }",
                      "    ",
                      "    // Performance analysis",
                      "    if (successfulChannels === totalChannels) {",
                      "        console.log('üéâ ALL NOTIFICATIONS DELIVERED SUCCESSFULLY');",
                      "        if (totalDeliveryTime / successfulChannels < 500) {",
                      "            console.log('üöÄ Excellent delivery performance (< 500ms average)');",
                      "        } else if (totalDeliveryTime / successfulChannels < 2000) {",
                      "            console.log('‚úÖ Good delivery performance (< 2s average)');",
                      "        } else {",
                      "            console.log('‚ö†Ô∏è Slow delivery performance (> 2s average)');",
                      "        }",
                      "    } else if (successfulChannels > 0) {",
                      "        console.log('‚ö†Ô∏è PARTIAL NOTIFICATION DELIVERY');",
                      "        console.log('üí° Check failed channels and their configurations');",
                      "    } else {",
                      "        console.log('‚ùå ALL NOTIFICATION DELIVERIES FAILED');",
                      "        console.log('üí° Check notification channel configurations and connectivity');",
                      "    }",
                      "} else {",
                      "    console.log('üì¢ === NOTIFICATION DELIVERY RESULTS ===');",
                      "    console.log('  ‚ö†Ô∏è No notification delivery information available');",
                      "}",
                      "",
                      "// Overall test result",
                      "console.log('üß™ === TEST ALERT VALIDATION ===');",
                      "if (pm.response.code === 200) {",
                      "    console.log('‚úÖ Test alert system is functioning correctly');",
                      "    console.log('üí° Alert configuration and delivery mechanisms are operational');",
                      "} else {",
                      "    console.log('‚ùå Test alert system has issues');",
                      "    console.log('üí° Review alert configuration and system logs');",
                      "}",
                      "",
                      "// Performance validation",
                      "if (pm.response.responseTime < 2000) {",
                      "    console.log('üöÄ Alert trigger performance is excellent');",
                      "} else if (pm.response.responseTime < 5000) {",
                      "    console.log('‚úÖ Alert trigger performance is acceptable');",
                      "} else {",
                      "    console.log('‚ö†Ô∏è Alert trigger performance is slow - investigate system load');",
                      "}",
                      "",
                      "console.log('üß™ === END TEST ALERT REPORT ===');"
                    ]
                  }
                }
              ]
            },
            {
              "name": "Check Alert Conditions",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  },
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "",
                  "options": {
                    "raw": {
                      "language": "json"
                    }
                  }
                },
                "url": {
                  "raw": "{{baseUrl}}/monitoring/check-alerts",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "monitoring",
                    "check-alerts"
                  ]
                },
                "description": "Manually trigger a check of all alert conditions to evaluate current system status against configured thresholds.\n\n**Authentication:** Required (Admin role only)\n**Authorization:** Admin role required\n**Rate Limiting:** Limited to prevent system overload (max 10 checks per hour)\n\n**Request Body:** Empty (no body required)\n\n**Response Format:**\n```json\n{\n  \"message\": \"Alert conditions checked successfully\",\n  \"checkedAt\": \"2024-01-15T10:30:00.000Z\",\n  \"evaluationResults\": {\n    \"totalRules\": 5,\n    \"evaluatedRules\": 5,\n    \"triggeredAlerts\": 1,\n    \"resolvedAlerts\": 0\n  },\n  \"ruleEvaluations\": [\n    {\n      \"ruleName\": \"High Queue Depth\",\n      \"condition\": \"queue_depth > 100\",\n      \"currentValue\": 150,\n      \"threshold\": 100,\n      \"status\": \"triggered\",\n      \"severity\": \"warning\",\n      \"lastTriggered\": \"2024-01-15T10:30:00.000Z\"\n    },\n    {\n      \"ruleName\": \"Processing Lag\",\n      \"condition\": \"processing_lag > 5000\",\n      \"currentValue\": 1200,\n      \"threshold\": 5000,\n      \"status\": \"normal\",\n      \"severity\": \"critical\"\n    }\n  ],\n  \"systemMetrics\": {\n    \"queueDepth\": {\n      \"email\": 150,\n      \"sms\": 25\n    },\n    \"processingLag\": {\n      \"email\": 1200,\n      \"sms\": 800\n    },\n    \"failureRate\": {\n      \"email\": 2.1,\n      \"sms\": 0.5\n    }\n  }\n}\n```\n\n**Rule Evaluation Status:**\n- `normal`: Condition is within acceptable thresholds\n- `triggered`: Condition has exceeded threshold and alert is active\n- `resolved`: Previously triggered condition has returned to normal\n- `disabled`: Rule is disabled and not evaluated\n- `error`: Rule evaluation failed due to configuration or data issues\n\n**Use Cases:**\n- Manual system health assessment\n- Validate alert rule configurations\n- Troubleshoot alert system behavior\n- Force immediate alert evaluation\n- Test alert conditions after system changes\n\n**Evaluation Process:**\n1. Retrieves current system metrics\n2. Evaluates each enabled alert rule\n3. Compares current values against thresholds\n4. Triggers new alerts for exceeded thresholds\n5. Resolves alerts for conditions that have normalized\n6. Updates alert history and status\n\n**Error Scenarios:**\n- 401 Unauthorized: Missing or invalid authentication\n- 403 Forbidden: Insufficient permissions (admin role required)\n- 429 Too Many Requests: Alert check rate limit exceeded\n- 500 Internal Server Error: Alert evaluation system issues\n- 503 Service Unavailable: Metrics collection unavailable"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Alert Conditions Check Test Suite",
                      "",
                      "pm.test('Alert conditions check completed successfully', function () {",
                      "    pm.expect(pm.response.code).to.equal(200);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable for alert evaluation', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(10000);",
                      "});",
                      "",
                      "pm.test('Response has valid alert check structure', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('object');",
                      "    pm.expect(responseJson).to.have.property('message');",
                      "    pm.expect(responseJson).to.have.property('checkedAt');",
                      "    pm.expect(responseJson).to.have.property('evaluationResults');",
                      "});",
                      "",
                      "pm.test('Evaluation results contain required metrics', function () {",
                      "    const results = pm.response.json().evaluationResults;",
                      "    pm.expect(results).to.have.property('totalRules');",
                      "    pm.expect(results).to.have.property('evaluatedRules');",
                      "    pm.expect(results).to.have.property('triggeredAlerts');",
                      "    pm.expect(results).to.have.property('resolvedAlerts');",
                      "});",
                      "",
                      "pm.test('Rule evaluations are present', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.have.property('ruleEvaluations');",
                      "    pm.expect(responseJson.ruleEvaluations).to.be.an('array');",
                      "});",
                      "",
                      "pm.test('System metrics are included', function () {",
                      "    const responseJson = pm.response.json();",
                      "    if (responseJson.systemMetrics) {",
                      "        pm.expect(responseJson.systemMetrics).to.be.an('object');",
                      "    }",
                      "});",
                      "",
                      "pm.test('Checked timestamp is valid and recent', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const checkedAt = new Date(responseJson.checkedAt);",
                      "    const now = new Date();",
                      "    const timeDiff = Math.abs(now.getTime() - checkedAt.getTime());",
                      "    ",
                      "    // Should be within last 30 seconds",
                      "    pm.expect(timeDiff).to.be.below(30000);",
                      "});",
                      "",
                      "// Detailed alert conditions analysis",
                      "const responseJson = pm.response.json();",
                      "",
                      "console.log('üîç === ALERT CONDITIONS CHECK REPORT ===');",
                      "console.log('üìä Checked At:', responseJson.checkedAt);",
                      "console.log('üìä Evaluation Time:', pm.response.responseTime + 'ms');",
                      "",
                      "// Evaluation summary",
                      "const results = responseJson.evaluationResults;",
                      "console.log('üìã === EVALUATION SUMMARY ===');",
                      "console.log('  Total Rules:', results.totalRules);",
                      "console.log('  Evaluated Rules:', results.evaluatedRules);",
                      "console.log('  Triggered Alerts:', results.triggeredAlerts);",
                      "console.log('  Resolved Alerts:', results.resolvedAlerts);",
                      "",
                      "// Rule evaluation coverage",
                      "const evaluationCoverage = results.totalRules > 0 ? (results.evaluatedRules / results.totalRules * 100).toFixed(1) : 0;",
                      "console.log('  Evaluation Coverage:', evaluationCoverage + '%');",
                      "",
                      "// Individual rule analysis",
                      "const ruleEvaluations = responseJson.ruleEvaluations;",
                      "console.log('üîç === RULE EVALUATION DETAILS ===');",
                      "",
                      "if (ruleEvaluations && ruleEvaluations.length > 0) {",
                      "    ruleEvaluations.forEach((rule, index) => {",
                      "        console.log(`  Rule ${index + 1}: ${rule.ruleName}`);",
                      "        console.log(`    Condition: ${rule.condition}`);",
                      "        console.log(`    Current Value: ${rule.currentValue}`);",
                      "        console.log(`    Threshold: ${rule.threshold}`);",
                      "        console.log(`    Status: ${rule.status.toUpperCase()}`);",
                      "        console.log(`    Severity: ${rule.severity.toUpperCase()}`);",
                      "        ",
                      "        if (rule.status === 'triggered') {",
                      "            console.log(`    üö® ALERT ACTIVE since ${rule.lastTriggered}`);",
                      "        } else if (rule.status === 'normal') {",
                      "            console.log(`    ‚úÖ Within normal parameters`);",
                      "        } else if (rule.status === 'resolved') {",
                      "            console.log(`    ‚úÖ Recently resolved`);",
                      "        } else if (rule.status === 'disabled') {",
                      "            console.log(`    ‚è∏Ô∏è Rule is disabled`);",
                      "        } else if (rule.status === 'error') {",
                      "            console.log(`    ‚ùå Evaluation error`);",
                      "        }",
                      "        console.log('');",
                      "    });",
                      "} else {",
                      "    console.log('  No rule evaluations available');",
                      "}",
                      "",
                      "// System metrics analysis",
                      "if (responseJson.systemMetrics) {",
                      "    console.log('üìä === CURRENT SYSTEM METRICS ===');",
                      "    const metrics = responseJson.systemMetrics;",
                      "    ",
                      "    if (metrics.queueDepth) {",
                      "        console.log('  Queue Depth:');",
                      "        console.log('    Email:', metrics.queueDepth.email);",
                      "        console.log('    SMS:', metrics.queueDepth.sms);",
                      "    }",
                      "    ",
                      "    if (metrics.processingLag) {",
                      "        console.log('  Processing Lag:');",
                      "        console.log('    Email:', metrics.processingLag.email + 'ms');",
                      "        console.log('    SMS:', metrics.processingLag.sms + 'ms');",
                      "    }",
                      "    ",
                      "    if (metrics.failureRate) {",
                      "        console.log('  Failure Rate:');",
                      "        console.log('    Email:', metrics.failureRate.email + '%');",
                      "        console.log('    SMS:', metrics.failureRate.sms + '%');",
                      "    }",
                      "}",
                      "",
                      "// Alert status analysis",
                      "console.log('üö® === ALERT STATUS ANALYSIS ===');",
                      "",
                      "if (results.triggeredAlerts > 0) {",
                      "    console.log('üö® ACTIVE ALERTS DETECTED');",
                      "    console.log('  Count:', results.triggeredAlerts);",
                      "    console.log('üí° Review triggered alerts and take corrective action');",
                      "    ",
                      "    // Count critical vs warning alerts",
                      "    const criticalAlerts = ruleEvaluations.filter(rule => ",
                      "        rule.status === 'triggered' && rule.severity === 'critical'",
                      "    ).length;",
                      "    const warningAlerts = results.triggeredAlerts - criticalAlerts;",
                      "    ",
                      "    if (criticalAlerts > 0) {",
                      "        console.log('  üî¥ Critical Alerts:', criticalAlerts);",
                      "        console.log('  ‚ö†Ô∏è Immediate attention required');",
                      "    }",
                      "    if (warningAlerts > 0) {",
                      "        console.log('  üü° Warning Alerts:', warningAlerts);",
                      "    }",
                      "} else {",
                      "    console.log('‚úÖ No active alerts - system is operating normally');",
                      "}",
                      "",
                      "if (results.resolvedAlerts > 0) {",
                      "    console.log('‚úÖ ALERTS RESOLVED');",
                      "    console.log('  Count:', results.resolvedAlerts);",
                      "    console.log('üí° Conditions have returned to normal thresholds');",
                      "}",
                      "",
                      "// System health assessment",
                      "console.log('üè• === SYSTEM HEALTH ASSESSMENT ===');",
                      "",
                      "const healthScore = results.totalRules > 0 ? ",
                      "    ((results.totalRules - results.triggeredAlerts) / results.totalRules * 100) : 100;",
                      "",
                      "console.log('  Health Score:', healthScore.toFixed(1) + '%');",
                      "",
                      "if (healthScore === 100) {",
                      "    console.log('üéâ SYSTEM HEALTH: EXCELLENT');",
                      "    console.log('  All alert conditions are within normal parameters');",
                      "} else if (healthScore >= 80) {",
                      "    console.log('‚úÖ SYSTEM HEALTH: GOOD');",
                      "    console.log('  Minor issues detected but system is stable');",
                      "} else if (healthScore >= 60) {",
                      "    console.log('‚ö†Ô∏è SYSTEM HEALTH: FAIR');",
                      "    console.log('  Multiple issues detected - monitoring recommended');",
                      "} else {",
                      "    console.log('üö® SYSTEM HEALTH: POOR');",
                      "    console.log('  Critical issues detected - immediate action required');",
                      "}",
                      "",
                      "// Performance analysis",
                      "console.log('‚ö° === PERFORMANCE ANALYSIS ===');",
                      "if (pm.response.responseTime < 3000) {",
                      "    console.log('üöÄ Alert evaluation performance is excellent');",
                      "} else if (pm.response.responseTime < 7000) {",
                      "    console.log('‚úÖ Alert evaluation performance is acceptable');",
                      "} else {",
                      "    console.log('‚ö†Ô∏è Alert evaluation performance is slow');",
                      "    console.log('üí° Consider optimizing alert rule complexity or system resources');",
                      "}",
                      "",
                      "// Recommendations",
                      "console.log('üí° === RECOMMENDATIONS ===');",
                      "if (results.triggeredAlerts === 0 && results.evaluatedRules === results.totalRules) {",
                      "    console.log('üéâ System is healthy and all monitoring is operational');",
                      "} else {",
                      "    if (results.triggeredAlerts > 0) {",
                      "        console.log('üîß Address active alerts to improve system health');",
                      "    }",
                      "    if (results.evaluatedRules < results.totalRules) {",
                      "        console.log('üîß Check disabled or failed alert rules');",
                      "    }",
                      "}",
                      "",
                      "console.log('üîç === END ALERT CONDITIONS CHECK REPORT ===');"
                    ]
                  }
                }
              ]
            }
          ]
        },
        {
          "name": "Health Checks",
          "description": "Detailed system health and component status checks",
          "item": [
            {
              "name": "Comprehensive System Health Check",
              "request": {
                "method": "GET",
                "header": [
                  {
                    "key": "Authorization",
                    "value": "Bearer {{accessToken}}",
                    "type": "text"
                  },
                  {
                    "key": "x-tenant-id",
                    "value": "{{tenantId}}",
                    "type": "text"
                  },
                  {
                    "key": "Content-Type",
                    "value": "application/json",
                    "type": "text"
                  }
                ],
                "url": {
                  "raw": "{{baseUrl}}/health/google-oauth",
                  "host": [
                    "{{baseUrl}}"
                  ],
                  "path": [
                    "health",
                    "google-oauth"
                  ]
                },
                "description": "Comprehensive system health check that validates all critical system components and their operational status. This endpoint provides detailed diagnostics for system monitoring and troubleshooting.\n\n**Authentication:** Required (Admin role only for detailed diagnostics)\n**Authorization:** Admin role required for full system diagnostics\n**Rate Limiting:** Standard admin rate limits apply\n\n**Health Check Coverage:**\n- Google OAuth service configuration and connectivity\n- Database connectivity and performance\n- Queue system health and processing status\n- Notification provider connectivity\n- External service dependencies\n- System resource utilization\n- Cache system status\n- Background job processing\n\n**Response Format:**\n```json\n{\n  \"status\": \"healthy\" | \"degraded\" | \"unhealthy\",\n  \"timestamp\": \"2024-01-15T10:30:00.000Z\",\n  \"uptime\": 86400,\n  \"version\": \"1.0.0\",\n  \"components\": {\n    \"googleOAuth\": {\n      \"status\": \"healthy\",\n      \"responseTime\": 150,\n      \"details\": {\n        \"configured\": true,\n        \"connectivity\": \"ok\"\n      }\n    },\n    \"database\": {\n      \"status\": \"healthy\",\n      \"responseTime\": 25,\n      \"details\": {\n        \"connections\": 5,\n        \"maxConnections\": 100\n      }\n    },\n    \"queues\": {\n      \"status\": \"healthy\",\n      \"details\": {\n        \"email\": { \"depth\": 0, \"processing\": true },\n        \"sms\": { \"depth\": 0, \"processing\": true }\n      }\n    }\n  },\n  \"metrics\": {\n    \"memoryUsage\": \"45%\",\n    \"cpuUsage\": \"12%\",\n    \"diskUsage\": \"68%\"\n  }\n}\n```\n\n**Health Status Levels:**\n- `healthy`: All components operational\n- `degraded`: Some non-critical issues detected\n- `unhealthy`: Critical issues requiring attention\n\n**Use Cases:**\n- Comprehensive system monitoring\n- Pre-deployment health validation\n- Troubleshooting system issues\n- Performance monitoring and optimization\n- Service level agreement monitoring\n\n**Error Scenarios:**\n- 401 Unauthorized: Missing or invalid authentication\n- 403 Forbidden: Insufficient permissions (admin role required)\n- 503 Service Unavailable: Critical system components unavailable"
              },
              "response": [],
              "event": [
                {
                  "listen": "test",
                  "script": {
                    "type": "text/javascript",
                    "exec": [
                      "// Comprehensive System Health Check Test Suite",
                      "",
                      "pm.test('System health check responds', function () {",
                      "    pm.expect(pm.response.code).to.be.oneOf([200, 503]);",
                      "});",
                      "",
                      "pm.test('Response time is acceptable for health check', function () {",
                      "    pm.expect(pm.response.responseTime).to.be.below(5000);",
                      "});",
                      "",
                      "pm.test('Response has valid health check structure', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson).to.be.an('object');",
                      "    pm.expect(responseJson).to.have.property('status');",
                      "    pm.expect(responseJson).to.have.property('timestamp');",
                      "});",
                      "",
                      "pm.test('Health status is valid', function () {",
                      "    const responseJson = pm.response.json();",
                      "    pm.expect(responseJson.status).to.be.oneOf(['healthy', 'degraded', 'unhealthy', 'ok', 'error']);",
                      "});",
                      "",
                      "pm.test('Timestamp is recent and valid', function () {",
                      "    const responseJson = pm.response.json();",
                      "    const timestamp = new Date(responseJson.timestamp);",
                      "    const now = new Date();",
                      "    const timeDiff = Math.abs(now.getTime() - timestamp.getTime());",
                      "    ",
                      "    // Should be within last 30 seconds",
                      "    pm.expect(timeDiff).to.be.below(30000);",
                      "});",
                      "",
                      "// Comprehensive system health analysis",
                      "const responseJson = pm.response.json();",
                      "",
                      "console.log('üè• === COMPREHENSIVE SYSTEM HEALTH REPORT ===');",
                      "console.log('üìä Overall Status:', (responseJson.status || 'unknown').toUpperCase());",
                      "console.log('üìä Timestamp:', responseJson.timestamp);",
                      "console.log('üìä Response Time:', pm.response.responseTime + 'ms');",
                      "",
                      "// System uptime and version",
                      "if (responseJson.uptime) {",
                      "    const uptimeHours = (responseJson.uptime / 3600).toFixed(2);",
                      "    const uptimeDays = (responseJson.uptime / 86400).toFixed(1);",
                      "    console.log('üìä System Uptime:', uptimeHours + ' hours (' + uptimeDays + ' days)');",
                      "}",
                      "if (responseJson.version) {",
                      "    console.log('üìä System Version:', responseJson.version);",
                      "}",
                      "",
                      "// Component health analysis",
                      "if (responseJson.components) {",
                      "    console.log('üîç === COMPONENT HEALTH ANALYSIS ===');",
                      "    ",
                      "    const components = responseJson.components;",
                      "    let healthyComponents = 0;",
                      "    let totalComponents = 0;",
                      "    ",
                      "    Object.entries(components).forEach(([componentName, component]) => {",
                      "        totalComponents++;",
                      "        const status = component.status || 'unknown';",
                      "        const responseTime = component.responseTime || 'N/A';",
                      "        ",
                      "        console.log(`  ${componentName.toUpperCase()}:`);",
                      "        console.log(`    Status: ${status.toUpperCase()}`);",
                      "        console.log(`    Response Time: ${responseTime}${typeof responseTime === 'number' ? 'ms' : ''}`);",
                      "        ",
                      "        if (component.details) {",
                      "            console.log('    Details:');",
                      "            Object.entries(component.details).forEach(([key, value]) => {",
                      "                console.log(`      ${key}: ${JSON.stringify(value)}`);",
                      "            });",
                      "        }",
                      "        ",
                      "        // Component status indicators",
                      "        if (status === 'healthy' || status === 'ok') {",
                      "            healthyComponents++;",
                      "            console.log('    ‚úÖ Component is operational');",
                      "        } else if (status === 'degraded') {",
                      "            console.log('    ‚ö†Ô∏è Component has performance issues');",
                      "        } else if (status === 'unhealthy' || status === 'error') {",
                      "            console.log('    ‚ùå Component has critical issues');",
                      "        } else {",
                      "            console.log('    ‚ùì Component status unknown');",
                      "}",
                      "        ",
                      "        // Performance analysis",
                      "        if (typeof responseTime === 'number') {",
                      "            if (responseTime < 100) {",
                      "                console.log('    üöÄ Excellent response time');",
                      "            } else if (responseTime < 500) {",
                      "                console.log('    ‚úÖ Good response time');",
                      "            } else if (responseTime < 2000) {",
                      "                console.log('    ‚ö†Ô∏è Slow response time');",
                      "            } else {",
                      "                console.log('    ‚ùå Very slow response time');",
                      "            }",
                      "        }",
                      "        console.log('');",
                      "    });",
                      "    ",
                      "    // Overall component health",
                      "    const componentHealthPercentage = totalComponents > 0 ? (healthyComponents / totalComponents * 100).toFixed(1) : 0;",
                      "    console.log('üìä === COMPONENT HEALTH SUMMARY ===');",
                      "    console.log('  Total Components:', totalComponents);",
                      "    console.log('  Healthy Components:', healthyComponents);",
                      "    console.log('  Health Percentage:', componentHealthPercentage + '%');",
                      "}",
                      "",
                      "// System metrics analysis",
                      "if (responseJson.metrics) {",
                      "    console.log('üìä === SYSTEM METRICS ===');",
                      "    const metrics = responseJson.metrics;",
                      "    ",
                      "    Object.entries(metrics).forEach(([metricName, value]) => {",
                      "        console.log(`  ${metricName}:`, value);",
                      "        ",
                      "        // Resource utilization alerts",
                      "        if (metricName.toLowerCase().includes('usage')) {",
                      "            const numericValue = parseFloat(value);",
                      "            if (!isNaN(numericValue)) {",
                      "                if (numericValue > 90) {",
                      "                    console.log(`    üö® CRITICAL: ${metricName} is very high`);",
                      "                } else if (numericValue > 75) {",
                      "                    console.log(`    ‚ö†Ô∏è WARNING: ${metricName} is high`);",
                      "                } else if (numericValue < 50) {",
                      "                    console.log(`    ‚úÖ GOOD: ${metricName} is normal`);",
                      "                }",
                      "            }",
                      "        }",
                      "    });",
                      "}",
                      "",
                      "// Overall system health assessment",
                      "console.log('üè• === OVERALL SYSTEM ASSESSMENT ===');",
                      "",
                      "const overallStatus = responseJson.status || 'unknown';",
                      "switch (overallStatus.toLowerCase()) {",
                      "    case 'healthy':",
                      "    case 'ok':",
                      "        console.log('üéâ SYSTEM STATUS: EXCELLENT');",
                      "        console.log('  All systems are operational and performing well');",
                      "        break;",
                      "    case 'degraded':",
                      "        console.log('‚ö†Ô∏è SYSTEM STATUS: DEGRADED');",
                      "        console.log('  Some performance issues detected but system is functional');",
                      "        console.log('üí° Monitor closely and consider optimization');",
                      "        break;",
                      "    case 'unhealthy':",
                      "    case 'error':",
                      "        console.log('üö® SYSTEM STATUS: UNHEALTHY');",
                      "        console.log('  Critical issues detected requiring immediate attention');",
                      "        console.log('üí° Review component details and take corrective action');",
                      "        break;",
                      "    default:",
                      "        console.log('‚ùì SYSTEM STATUS: UNKNOWN');",
                      "        console.log('  Unable to determine system health status');",
                      "}",
                      "",
                      "// Performance assessment",
                      "console.log('‚ö° === PERFORMANCE ASSESSMENT ===');",
                      "if (pm.response.responseTime < 1000) {",
                      "    console.log('üöÄ Health check performance: EXCELLENT');",
                      "} else if (pm.response.responseTime < 3000) {",
                      "    console.log('‚úÖ Health check performance: GOOD');",
                      "} else {",
                      "    console.log('‚ö†Ô∏è Health check performance: SLOW');",
                      "    console.log('üí° Consider optimizing health check processes');",
                      "}",
                      "",
                      "// Recommendations",
                      "console.log('üí° === RECOMMENDATIONS ===');",
                      "if (overallStatus === 'healthy' || overallStatus === 'ok') {",
                      "    console.log('üéØ Continue regular monitoring and maintenance');",
                      "    console.log('üìà Consider performance optimization opportunities');",
                      "} else if (overallStatus === 'degraded') {",
                      "    console.log('üîß Investigate performance bottlenecks');",
                      "    console.log('üìä Review system metrics and component details');",
                      "    console.log('‚ö° Consider scaling or optimization');",
                      "} else if (overallStatus === 'unhealthy' || overallStatus === 'error') {",
                      "    console.log('üö® IMMEDIATE ACTION REQUIRED');",
                      "    console.log('üîç Review failed components and error logs');",
                      "    console.log('üìû Consider escalating to system administrators');",
                      "    console.log('üõ†Ô∏è Implement emergency procedures if necessary');",
                      "}",
                      "",
                      "console.log('üè• === END SYSTEM HEALTH REPORT ===');"
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}